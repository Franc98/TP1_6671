<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

    	<center>    		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>

        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script src="js/bezier.js" type="module"></script>
        
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);

                //gl_FragColor = vec4(vNormal,1.0); 
                gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script>


            var mat4=glMatrix.mat4;
            var vec3=glMatrix.vec3;
            var vec4=glMatrix.vec4;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            trianglesIndexBuffer = null;
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();
            var rotate_angle = -1.57078;

            var buffersSupBarrido;
            var objetos3D;
         
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {

                    setupWebGL();
                    initShaders();
                    setupBuffers();
                    probarBezier();
                    probarSuperficieDeBarrido();
                    setupVertexShaderMatrix();
                    inicializarObjetos();
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 100.0);
                
                mat4.identity(modelMatrix);
                mat4.rotate(modelMatrix,modelMatrix, -1.57078, [1.0, 0.0, 0.0]);

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
            }
                    
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }
            
            function getPos(alfa,beta){

                var r=2;
                var nx=Math.sin(beta)*Math.sin(alfa);
                var ny=Math.sin(beta)*Math.cos(alfa);
                var nz=Math.cos(beta);


                var g=beta%0.5;
                var h=alfa%1;
                var f=1;

                if (g<0.25) f=0.95;
                if (h<0.5) f=f*0.95;
                
                var x=nx*r*f;
                var y=ny*r*f;
                var z=nz*r*f;

                return [x,y,z];
            }

            function getNrm(alfa,beta){
                var p=getPos(alfa,beta);
                var v=vec3.create();
                vec3.normalize(v,p);

                var delta=0.05;
                var p1=getPos(alfa,beta);
                var p2=getPos(alfa,beta+delta);
                var p3=getPos(alfa+delta,beta);

                var v1=vec3.fromValues(p2[0]-p1[0],p2[1]-p1[1],p2[2]-p1[2]);
                var v2=vec3.fromValues(p3[0]-p1[0],p3[1]-p1[1],p3[2]-p1[2]);

                vec3.normalize(v1,v1);
                vec3.normalize(v2,v2);
                
                var n=vec3.create();
                vec3.cross(n,v1,v2);
                vec3.scale(n,n,-1);
                return n;
            }


            function setupBuffers()
            {
                var pos=[];
                var normal=[];
                var r=2;
                var rows=128;
                var cols=256;

                for (var i=0;i<rows;i++){
                    for (var j=0;j<cols;j++){

                        var alfa=j/(cols-1)*Math.PI*2;
                        var beta=(0.1+i/(rows-1)*0.8)*Math.PI;

                        var p=getPos(alfa,beta);

                        pos.push(p[0]);
                        pos.push(p[1]);
                        pos.push(p[2]);

                        var n=getNrm(alfa,beta);

                        normal.push(n[0]);
                        normal.push(n[1]);
                        normal.push(n[2]);
                    }

                }
      
                trianglesVerticeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);    
            

                trianglesNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, trianglesNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW);

                var index=[];

                for (var i=0;i<rows-1;i++){
                    index.push(i*cols);
                    for (var j=0;j<cols-1;j++){
                        index.push(i*cols+j);
                        index.push((i+1)*cols+j);
                        index.push(i*cols+j+1);
                        index.push((i+1)*cols+j+1);
                    }
                    index.push((i+1)*cols+cols-1);
                }
                
                
                trianglesIndexBuffer = gl.createBuffer();
                trianglesIndexBuffer.number_vertex_point = index.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trianglesIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(index), gl.STATIC_DRAW);    
            }

            /*
            *
            *
            */
            function bezierRecursivo(puntosDeControl, u, grado)
            {

                var puntosNuevos = [];

                var xm;
                var ym;
                var zm;


                for (var i = 0; i < grado; i++) 
                {
                    xm = (1-u)*puntosDeControl[3*(i)] + u*puntosDeControl[3*(i+1)];
                    ym = (1-u)*puntosDeControl[3*(i)+1] + u*puntosDeControl[3*(i+1)+1];
                    zm = (1-u)*puntosDeControl[3*(i)+2] + u*puntosDeControl[3*(i+1)+2];

                    puntosNuevos.push(xm);
                    puntosNuevos.push(ym);
                    puntosNuevos.push(zm);
                }

                if(grado <= 1)
                {
                    xm = puntosDeControl[3] - puntosDeControl[0];
                    ym = puntosDeControl[4] - puntosDeControl[1];
                    zm = puntosDeControl[5] - puntosDeControl[2];
                    var vectorTangente = vec3.fromValues(xm,ym,zm);
                    vec3.normalize(vectorTangente, vectorTangente);


                    return {
                        puntosNuevos,
                        vectorTangente
                    };
                }
                else 
                {
                    return bezierRecursivo(puntosNuevos, u, grado-1);
                }
                
            }

            function calcularBinormal(puntos)
            {
                var longitud = puntos.length;

                var v1 = vec3.fromValues(puntos[longitud-3],puntos[longitud-2],puntos[longitud-1]);
                var v2 = vec3.fromValues(puntos[longitud-6],puntos[longitud-5],puntos[longitud-4]);
                var v3 = vec3.fromValues(puntos[longitud-9],puntos[longitud-8],puntos[longitud-7]);


                var v12 = vec3.create();
                var v23 = vec3.create();
                var binormal = vec3.create();

                var normal = vec3.create();
                var v32 = vec3.create();

                vec3.sub(v12,v1,v2);
                vec3.sub(v23,v2,v3);

                vec3.cross(binormal,v12,v23);
                //vec3.cross(binormal,v23,v12);
                

                vec3.normalize(binormal, binormal);


                // harcodeo binormal eje z
                //vec3.set(binormal,0.0,0.0,1.0);

                return binormal;

            }

            function bezier(puntosDeControl, cantidadPuntosFinal, grado)
            {

                // iteracion -1
                var paso = 1.0/(cantidadPuntosFinal-1);
                var puntoBezier = bezierRecursivo(puntosDeControl, -paso, grado)



                var posicion = puntoBezier.puntosNuevos;
                var tangente = [];
                var normal = [];
                var binormal = [];

                var tangenteActual;
                var binormalActual;
                var normalActural = vec3.create();

                // itracion 0

                puntoBezier = bezierRecursivo(puntosDeControl, 0.0, grado);
                posicion.push(puntoBezier.puntosNuevos[0]);
                posicion.push(puntoBezier.puntosNuevos[1]);
                posicion.push(puntoBezier.puntosNuevos[2]);

                tangenteActual = puntoBezier.vectorTangente;

                tangente.push(tangenteActual[0]);
                tangente.push(tangenteActual[1]);
                tangente.push(tangenteActual[2]);

                for (var i = 1; i<cantidadPuntosFinal+1; i++)
                {
                    puntoBezier = bezierRecursivo(puntosDeControl, i*paso, grado);
                    posicion.push(puntoBezier.puntosNuevos[0]);
                    posicion.push(puntoBezier.puntosNuevos[1]);
                    posicion.push(puntoBezier.puntosNuevos[2]);

                    binormalActual = calcularBinormal(posicion);
                    vec3.cross(normalActural,tangenteActual,binormalActual);
                    //vec3.cross(normalActural,binormalActual,tangenteActual);
                    vec3.normalize(normalActural,normalActural)

                    normal.push(normalActural[0]);
                    normal.push(normalActural[1]);
                    normal.push(normalActural[2]);

                    binormal.push(binormalActual[0]);
                    binormal.push(binormalActual[1]);
                    binormal.push(binormalActual[2]);

                    tangenteActual = puntoBezier.vectorTangente;

                    tangente.push(tangenteActual[0]);
                    tangente.push(tangenteActual[1]);
                    tangente.push(tangenteActual[2]);
                }

                // elimino primer y último punto
                // elimino última tangente

                posicion.pop();
                posicion.pop();
                posicion.pop();

                posicion.shift();
                posicion.shift();
                posicion.shift();

                tangente.pop();
                tangente.pop();
                tangente.pop();

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal
                };

            }

            function bezierCompleto(puntosControl,cantidadPuntosFinalTotal, grado)
            {
                var cantidadCurvas = Math.floor(puntosControl.length/(3*(grado+1)));
                var cantidadPuntosPorCurva = Math.ceil(cantidadPuntosFinalTotal/cantidadCurvas);
                var cantidadPuntosFinal = cantidadPuntosPorCurva*cantidadCurvas;

                var posicion = [];
                var tangente = [];
                var normal = [];
                var binormal = [];

                var puntosControlUsados;
                var bezier2;

                for(var i = 0; i<cantidadCurvas; i++)
                {
                    puntosControlUsados = puntosControl.slice(3*(grado+1)*i,3*(grado+1)*(i+1));
                    bezier2 = bezier(puntosControlUsados, cantidadPuntosPorCurva, grado);
                    posicion = posicion.concat(bezier2.posicion);
                    tangente = tangente.concat(bezier2.tangente);
                    normal = normal.concat(bezier2.normal);
                    binormal = binormal.concat(bezier2.binormal);
                }

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };

            }

            var bezierVerticeBuffer = null;
            var bezierNormalBuffer = null;
            var bezierIndexBuffer = null;

            function probarBezier()
            {
                /*
                const vectorVertices = 
                [
                    2.0,0.0,0.0,
                    2.0,2.0,0.0,
                    0.0,2.0,0.0,

                    0.0,2.0,0.0,
                    -2.0,2.0,0.0,
                    -2.0,0.0,0.0,

                    -2.0,0.0,0.0,
                    -2.0,-2.0,0.0,
                    0.0,-2.0,0.0,

                    0.0,-2.0,0.0,
                    2.0,-2.0,0.0,
                    2.0,0.0,0.0,
                ];
                */
                /*
                const vectorVertices = 
                [
                    -1.0,0.0,0.0,
                    -1.0,0.0,-1.0,
                    0.0,0.0,-1.0,

                    0.0,0.0,-1.0,
                    1.0,0.0,-1.0,
                    1.0,0.0,0.0,
                ];
                */
                const vectorVertices = 
                [
                    -1.0,0.0,0.0,
                    -1.0,-1.0,0.0,
                    0.0,-1.0,0.0,

                    0.0,-1.0,0.0,
                    1.0,-1.0,0.0,
                    1.0,0.0,0.0,
                ];
                

                var puntosBezier = bezierCompleto(vectorVertices,100, 2);
                var pos = puntosBezier.posicion;
                var norm = puntosBezier.normal;
                var puntos = puntosBezier.cantidadPuntosFinal;

                var indice = [];

                for (let index = 0; index < puntos; index++) 
                {
                    indice.push(index);                    
                }

                bezierVerticeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, bezierVerticeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);    
            

                bezierNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, bezierNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(norm), gl.STATIC_DRAW);
                
                
                bezierIndexBuffer = gl.createBuffer();
                bezierIndexBuffer.number_vertex_point = indice.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bezierIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indice), gl.STATIC_DRAW);  

            }

            function calcularValorBufferUVSuperficie(posicionesUoV, cantidadPuntosUoV)
            {
                var tablaPosiciones = [0];
                var puntoAnterior= vec3.create();
                var puntoSiguiente = vec3.fromValues(posicionesUoV[0],posicionesUoV[1],posicionesUoV[2]);
                var distancia;
                var max;
                for(var i = 1; i < cantidadPuntosUoV; i++)
                {
                    vec3.copy(puntoAnterior,puntoSiguiente);
                    vec3.set(puntoSiguiente,posicionesUoV[3*(i-1)],posicionesUoV[3*(i-1)+1],posicionesUoV[3*(i-1)+2]);
                    distancia = vec3.distance(puntoAnterior, puntoSiguiente);
                    tablaPosiciones.push(tablaPosiciones[i-1]+distancia);
                }
                max = tablaPosiciones[cantidadPuntosUoV-1];
                for(var i = 0; i < cantidadPuntosUoV; i++)
                {
                    tablaPosiciones[i] = tablaPosiciones[i]/max;
                }
                return tablaPosiciones;
            }

            function obtenerMatricesTransformacion(recorrido, matrizRotoEscalado, punto)
            {
                var normal = recorrido.normal;
                var posicion = recorrido.posicion;
                var tangente = recorrido.tangente;
                var binormal = recorrido.binormal;

                var a = [];

                a.push(normal[3*punto]);
                a.push(normal[3*punto+1]);
                a.push(normal[3*punto+2]);
                a.push(0);
                a.push(binormal[3*punto]);
                a.push(binormal[3*punto+1]);
                a.push(binormal[3*punto+2]);
                a.push(0);
                a.push(tangente[3*punto]);
                a.push(tangente[3*punto+1]);
                a.push(tangente[3*punto+2]);
                a.push(0);
                a.push(posicion[3*punto]);
                a.push(posicion[3*punto+1]);
                a.push(posicion[3*punto+2]);
                a.push(1);

                var matrizModelado = mat4.fromValues(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]);
                mat4.multiply(matrizModelado, matrizRotoEscalado, matrizModelado);
                var matrizNormal = mat4.create();
                
                mat4.invert(matrizNormal,matrizModelado);
                mat4.transpose(matrizNormal,matrizNormal);
                
                return{
                    matrizModelado,
                    matrizNormal
                };
            }

            function obtnerMatrixRotoEscalado(escalados,angulosRotacion,vectoresRotacion, paso)
            {
                var matrixRotoEscalado = mat4.create();
                var vectorRotacion;
                var vectorEscalado;
                mat4.identity(matrixRotoEscalado);
                if (angulosRotacion != null)
                {
                    vectorRotacion = vec3.fromValues(vectoresRotacion[3*paso],vectoresRotacion[3*paso+1],vectoresRotacion[3*paso+2])
                    mat4.rotate(matrixRotoEscalado,matrixRotoEscalado,angulosRotacion[paso],vectorRotacion);
                }
                if (escalados != null)
                {
                    vectorEscalado = vec3.fromValues(escalados[3*paso],escalados[3*paso+1],escalados[3*paso+2])
                    mat4.scale(matrixRotoEscalado,matrixRotoEscalado,vectorEscalado);
                }
                return matrixRotoEscalado;
            }

            function obtenerTransformacionNivel(nivel, matrizModelado, matrizNormal, bufferU, valorV)
            {
                var bufferPuntos = [];
                var bufferNormales = [];
                var bufferUV = [];
                var punto = vec3.create();
                var normal = vec4.create();
                for(var i = 0; i<nivel.cantidadPuntosFinal; i++)
                {   
                    vec3.set(punto,nivel.posicion[3*i],nivel.posicion[3*i+1],nivel.posicion[3*i+2]);
                    vec4.set(normal,nivel.normal[3*i],nivel.normal[3*i+1],nivel.normal[3*i+2],1);
                    vec3.transformMat4(punto,punto,matrizModelado);
                    vec4.transformMat4(normal,normal,matrizNormal);
                    //invierto signo normal
                    vec4.scale(normal,normal,-1);

                    bufferPuntos.push(punto[0],punto[1],punto[2]);
                    bufferNormales.push(normal[0],normal[1],normal[2]);
                    bufferUV.push(bufferU[i],valorV);
                }
                return{
                    bufferPuntos,
                    bufferNormales,
                    bufferUV
                };
            }

            function obtenerIndexBuffer(cantidadFilas, cantidadColumnas)
            {
                var indexBuffer=[];  
                //indexBuffer=[0,1,2,2,1,3]; // Estos valores iniciales harcodeados solo dibujan 2 triangulos, REMOVER ESTA LINEA!

                var verticeSuperior;
                var verticeinferior;
                
                for (i=0; i < cantidadFilas-1; i++) {
                    verticeSuperior = i*(cantidadColumnas);
                    verticeinferior = (i+1)*(cantidadColumnas);
                    for (j=0; j < cantidadColumnas-1; j++) {

                        indexBuffer.push(verticeSuperior);
                        indexBuffer.push(verticeinferior);

                        verticeSuperior = verticeSuperior + 1;
                        verticeinferior = verticeinferior + 1;
                        
                    }

                    // oara el cambio de linea
                    indexBuffer.push(verticeSuperior);
                    indexBuffer.push(verticeinferior);

                    indexBuffer.push(verticeinferior);
                    indexBuffer.push((i+1)*(cantidadColumnas));

                    
                }
                return indexBuffer;
            }

            function calcularValorBufferUVTapas(posicionesTapa, cantidadPuntos)
            {
                var bufferUVBorde = [];
                var bufferUVCentro = [];
                var xmax = posicionesTapa[0];
                var xmin = xmax;
                var ymax = posicionesTapa[1];
                var ymin = ymax;
                var xaux;
                var yaux;
                var xpromedio = xmax;
                var ypromedio = ymax;

                for(var i = 1; i < cantidadPuntos; i++)
                {
                    xaux = posicionesTapa[3*i];
                    yaux = posicionesTapa[3*i+1];
                    xpromedio += xaux;
                    ypromedio += yaux;
                    if(xaux > xmax)
                    {
                        xmax = xaux;
                    }
                    if(xaux < xmin)
                    {
                        xmin = xaux;
                    }
                    if(yaux > ymax)
                    {
                        ymax = yaux;
                    }
                    if(yaux < ymin)
                    {
                        ymin = yaux;
                    }
                }
                xpromedio = xpromedio/cantidadPuntos;
                ypromedio = ypromedio/cantidadPuntos;
                var xdif = xmax-xmin;
                var ydif = ymax-ymin;

                xaux = xpromedio - xmin;
                xpromedio = xaux/xdif;
                yaux = ypromedio - ymin;
                ypromedio = yaux/ydif;

                for(var i = 0; i < cantidadPuntos; i++)
                {
                    xaux = posicionesTapa[3*i] - xmin;
                    xaux = xaux/xdif;
                    yaux = posicionesTapa[3*i+1] - ymin;
                    yaux = yaux/ydif;
                    bufferUVBorde.push(xaux);
                    bufferUVBorde.push(yaux);
                    bufferUVCentro.push(xpromedio);
                    bufferUVCentro.push(ypromedio);
                }
                return{
                    bufferUVBorde,
                    bufferUVCentro
                };
                  
            }

            function generarSuperficieDeBarrido(nivel,recorrido,escalados = null,angulosRotacion = null)
            {
                var nivelNuevo;
                var matrices;
                var matrizRotoEscalado;

                var bufferPuntos = [];
                var bufferNormales = [];
                var bufferUV = [];
                var bufferIndices;

                var bufferU = calcularValorBufferUVSuperficie(nivel.posicion,nivel.cantidadPuntosFinal);
                var bufferV = calcularValorBufferUVSuperficie(recorrido.posicion,recorrido.cantidadPuntosFinal);

                for (var i = 0; i < recorrido.cantidadPuntosFinal; i++) 
                
                {
                    matrizRotoEscalado = obtnerMatrixRotoEscalado(escalados, angulosRotacion, recorrido.tangente, i);
                    matrices = obtenerMatricesTransformacion(recorrido, matrizRotoEscalado, i);    
                    nivelNuevo = obtenerTransformacionNivel(nivel, matrices.matrizModelado, matrices.matrizNormal, bufferU, bufferV[i]);
                    bufferPuntos = bufferPuntos.concat(nivelNuevo.bufferPuntos);
                    bufferNormales = bufferNormales.concat(nivelNuevo.bufferNormales);
                    bufferUV = bufferUV.concat(nivelNuevo.bufferUV);
                    
                }
                bufferIndices = obtenerIndexBuffer(recorrido.cantidadPuntosFinal, nivel.cantidadPuntosFinal);

                return{
                    bufferPuntos,
                    bufferNormales,
                    bufferUV,
                    bufferIndices
                };

            }

            function superficieBarridoCompleta(nivel,recorrido,escalados = null,angulosRotacion = null,tapaInicial = true, tapaFinal = true)
            {
                var buffersSuperficie = generarSuperficieDeBarrido(nivel, recorrido, escalados, angulosRotacion);
                var tangenteRecorrido;
                var centroTapaX = 0;
                var centroTapaY = 0;
                var centroTapaZ = 0;
                var puntosTapa;
                var cantidadFilas = recorrido.cantidadPuntosFinal;
                var cantidadFilasFinal = cantidadFilas;
                var cantidadColumnas = nivel.cantidadPuntosFinal;
                var cantidadTotalPuntos = cantidadFilas*cantidadColumnas;


                var bufferPosicion = [];
                var bufferNormal = [];
                var bufferUV = [];
                var bufferIndice;

                var bufferUVAux = calcularValorBufferUVTapas(nivel.posicion, cantidadColumnas);
                
                if(tapaInicial)
                {
                    puntosTapa = buffersSuperficie.bufferPuntos.slice(0,3*cantidadColumnas);
                    tangenteRecorrido = recorrido.tangente.slice(0,3);
                    tangenteRecorrido = vec3.scale(tangenteRecorrido,tangenteRecorrido,-1);
                    //console.log(tangenteRecorrido);
                    centroTapaX = 0;
                    centroTapaY = 0;
                    centroTapaZ = 0;
                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        centroTapaX += puntosTapa[3*i];
                        centroTapaY += puntosTapa[3*i+1];
                        centroTapaZ += puntosTapa[3*i+2];
                        bufferNormal.push(tangenteRecorrido[0],tangenteRecorrido[1],tangenteRecorrido[2]);
                        bufferNormal.push(tangenteRecorrido[0],tangenteRecorrido[1],tangenteRecorrido[2]);
                    }
                    centroTapaX = centroTapaX/cantidadColumnas;
                    centroTapaY = centroTapaY/cantidadColumnas;
                    centroTapaZ = centroTapaZ/cantidadColumnas;

                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        bufferPosicion.push(centroTapaX,centroTapaY,centroTapaZ);
                    }
                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        bufferPosicion.push(puntosTapa[3*i],puntosTapa[3*i+1],puntosTapa[3*i+2]);
                    }
                    
                    bufferUV = bufferUV.concat(bufferUVAux.bufferUVCentro);
                    bufferUV = bufferUV.concat(bufferUVAux.bufferUVBorde);

                    cantidadFilasFinal += 2;
                }

                bufferPosicion = bufferPosicion.concat(buffersSuperficie.bufferPuntos);
                bufferNormal = bufferNormal.concat(buffersSuperficie.bufferNormales);
                bufferUV = bufferUV.concat(buffersSuperficie.bufferUV);

                if(tapaFinal)
                {
                    puntosTapa = buffersSuperficie.bufferPuntos.slice(3*(cantidadTotalPuntos-cantidadColumnas),3*cantidadTotalPuntos);
                    tangenteRecorrido = recorrido.tangente.slice(3*(cantidadFilas-1),3*cantidadFilas);
                    centroTapaX = 0;
                    centroTapaY = 0;
                    centroTapaZ = 0;
                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        centroTapaX += puntosTapa[3*i];
                        centroTapaY += puntosTapa[3*i+1];
                        centroTapaZ += puntosTapa[3*i+2];
                        bufferNormal.push(tangenteRecorrido[0],tangenteRecorrido[1],tangenteRecorrido[2]);
                        bufferNormal.push(tangenteRecorrido[0],tangenteRecorrido[1],tangenteRecorrido[2]);
                        bufferPosicion.push(puntosTapa[3*i],puntosTapa[3*i+1],puntosTapa[3*i+2]);                        
                    }
                    centroTapaX = centroTapaX/cantidadColumnas;
                    centroTapaY = centroTapaY/cantidadColumnas;
                    centroTapaZ = centroTapaZ/cantidadColumnas;

                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        bufferPosicion.push(centroTapaX,centroTapaY,centroTapaZ);
                    }
                    bufferUV = bufferUV.concat(bufferUVAux.bufferUVBorde);
                    bufferUV = bufferUV.concat(bufferUVAux.bufferUVCentro);
                    cantidadFilasFinal += 2;
                }

                bufferIndice = obtenerIndexBuffer(cantidadFilasFinal,cantidadColumnas);

                var supBarridoVerticeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, supBarridoVerticeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bufferPosicion), gl.STATIC_DRAW);    
            

                var supBarridoNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, supBarridoNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bufferNormal), gl.STATIC_DRAW);
                
                
                var supBarridoIndexBuffer = gl.createBuffer();
                supBarridoIndexBuffer.number_vertex_point = bufferIndice.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, supBarridoIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(bufferIndice), gl.STATIC_DRAW); 


                return {
                    supBarridoVerticeBuffer,
                    supBarridoNormalBuffer,
                    supBarridoIndexBuffer
                };
            }

            function generarRecta(longitud)
            {
                var posicion = [-longitud/2,0.0,0.0,longitud/2,0.0,0.0];
                var tangente = [1.0,0.0,0.0,1.0,0.0,0.0];
                var normal = [0.0,0.0,1.0,0.0,0.0,1.0];
                var binormal = [0.0,1.0,0.0,0.0,1.0,0.0];
                var cantidadPuntosFinal = 2;
                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };
            }
            
            function generarRectangulo(base, altura)
            {
                var posicion = 
                [
                    base/2,altura/2,0.0,
                    -base/2,altura/2,0.0,
                    -base/2,altura/2,0.0,
                    -base/2,-altura/2,0.0,
                    -base/2,-altura/2,0.0,
                    base/2,-altura/2,0.0,
                    base/2,-altura/2,0.0,
                    base/2,altura/2,0.0
                ];
                var tangente = 
                [
                    -1.0,0.0,0.0,
                    -1.0,0.0,0.0,
                    0.0,-1.0,0.0,
                    0.0,-1.0,0.0,
                    1.0,0.0,0.0,
                    1.0,0.0,0.0,
                    0.0,1.0,0.0,
                    0.0,1.0,0.0
                ];
                var normal = 
                [
                    0.0,-1.0,0.0,
                    0.0,-1.0,0.0,
                    1.0,0.0,0.0,
                    1.0,0.0,0.0,
                    0.0,1.0,0.0,
                    0.0,1.0,0.0,
                    -1.0,0.0,0.0,
                    -1.0,0.0,0.0
                ];
                var binormal = 
                [
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0
                ];
                var cantidadPuntosFinal = 8;
                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };
            }

            function generarArcoCircunferencia(radio,cantidadPuntos,anguloEnGrados=360)
            {
                var anguloMax = anguloEnGrados*Math.PI/180;
                var pasoAngulo = anguloMax/(cantidadPuntos-1);
                var posicion = [];
                var tangente = [];
                var normal = [];
                var binormal = [];
                var cantidadPuntosFinal = cantidadPuntos;
                var coseno;
                var seno;
                var angulo;
                for(var i=0; i<cantidadPuntos;i++)
                {   
                    angulo = pasoAngulo*i;
                    coseno = Math.cos(angulo);
                    seno = Math.sin(angulo);
                    posicion.push(radio*coseno,radio*seno,0.0);
                    tangente.push(-seno,coseno,0.0);
                    normal.push(-coseno,-seno,0.0);
                    binormal.push(0.0,0.0,-1.0);
                }
                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };
            }
            
            var sBVerticeBuffer;
            var sBNormalBuffer;
            var sBIndexBuffer;

            function probarSuperficieDeBarrido()
            {
                
                const nivelControl = 
                [
                    0.5,0.0,0.0,
                    0.5,0.5,0.0,
                    0.0,0.5,0.0,

                    0.0,0.5,0.0,
                    -0.5,0.5,0.0,
                    -0.5,0.0,0.0,

                    -0.5,0.0,0.0,
                    -0.5,-0.5,0.0,
                    0.0,-0.5,0.0,

                    0.0,-0.5,0.0,
                    0.5,-0.5,0.0,
                    0.5,0.0,0.0,
                ];
                
                const recorridoControl = 
                [
                    -1.0,0.0,0.0,
                    -1.0,0.0,-1.0,
                    0.0,0.0,-1.0,

                    0.0,0.0,-1.0,
                    1.0,0.0,-1.0,
                    1.0,0.0,0.0,
                ];
                
                /*
                const recorridoControl = 
                [
                    -1.0,0.0,0.0,
                    -1.0,-1.0,0.0,
                    0.0,-1.0,0.0,

                    0.0,-1.0,0.0,
                    1.0,-1.0,0.0,
                    1.0,0.0,0.0,
                ];
                */
                
                //var recorrido = bezierCompleto(recorridoControl,100,2);
                // var nivel = bezierCompleto(nivelControl,100,2);
                var recorrido = generarRecta(2)
                var nivel = generarArcoCircunferencia(1,100);
                var buffers = generarSuperficieDeBarrido(nivel,recorrido);

                //console.log(buffers.bufferPuntos);
                //console.log(buffers.bufferNormales);
                //console.log(buffers.bufferIndices);

                sBVerticeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sBVerticeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffers.bufferPuntos), gl.STATIC_DRAW);    
            

                sBNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sBNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffers.bufferNormales), gl.STATIC_DRAW);
                
                
                sBIndexBuffer = gl.createBuffer();
                sBIndexBuffer.number_vertex_point = buffers.bufferIndices.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sBIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(buffers.bufferIndices), gl.STATIC_DRAW);  
                
                //var recorrido = bezierCompleto(recorridoControl,100,2);
                //var nivel = bezierCompleto(nivelControl,100,2);
                buffersSupBarrido = superficieBarridoCompleta(nivel,recorrido);

            }

            //function gererarEsfera(radio,cantidadFilas,cantidadColumas)
            class Objeto3D
            {
                // atributos privados
                constructor(vertexBuffer,normalBuffer,uVBuffer,indexBuffer,matrizModelado,matrizNormal,posicion,rotacionEje,rotacionAngulo,escala,color,hijos)
                {
                    //buffers
                    this.vertexBuffer = null;
                    this.normalBuffer = null;
                    this.uVBuffer = null;
                    this.indexBuffer = null;
                    //matricex
                    this.matrizModelado = mat4.create();
                    this.matrizNormal = mat4.create();
                    // parametros
                    this.posicion =vec3.create();
                    this.rotacionEje = vec3.create();
                    this.rotacionAngulo = 0;
                    this.escala = vec3.fromValues(1,1,1);
                    this.color = vec3.create();
                    // hijos
                    this.hijos = [];
                } 
                // método privado, usa posición, rotación y escala
                actualizarMatrizModelado()
                {
                    mat4.identity(this.matrizModelado);
                    mat4.translate(this.matrizModelado,this.matrizModelado,this.posicion);
                    mat4.rotate(this.matrizModelado,this.matrizModelado,this.rotacionAngulo,this.rotacionEje);
                    mat4.scale(this.matrizModelado,this.matrizModelado,this.escala);
                    //console.log(this.matrizModelado);
                }
                actualizarMatrizNormal(matrizVista,matrizM)
                {
                    mat4.multiply(this.matrizNormal,matrizVista,matrizM);
                    mat4.invert(this.matrizNormal,this.matrizNormal);
                    mat4.transpose(this.matrizNormal,this.matrizNormal);
                }
                // métodos públicos
                dibujar (matrizVista, matrizPadre = null)
                {
                    var m = mat4.create();
                    this.actualizarMatrizModelado();
                    
                    // concatenamos las transformaciones padre/hijo
                    if(matrizPadre)
                        mat4.multiply(m, matrizPadre, this.matrizModelado);
                    else
                        mat4.copy(m, this.matrizModelado)

                    this.actualizarMatrizNormal(matrizVista, m);

                    if(this.vertexBuffer && this.indexBuffer)
                    {
                    // setear matrices modelado y normales
                    var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
                    var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                    gl.uniformMatrix4fv(modelMatrixUniform, false, m);
                    gl.uniformMatrix4fv(normalMatrixUniform, false, this.matrizNormal);

                    //setear buffers    
                    vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                    gl.enableVertexAttribArray(vertexPositionAttribute);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                    vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                    gl.enableVertexAttribArray(vertexNormalAttribute);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
                    gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    gl.drawElements( gl.TRIANGLE_STRIP, this.indexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                    }

                    for(var i=0;i< this.hijos.length;i++)
                    {
                        this.hijos[i].dibujar(matrizVista, m);
                    } 
                }
                setGeometria (vertexBuffer,normalBuffer,uVBuffer,indexBuffer)
                {
                    this.vertexBuffer = vertexBuffer;
                    this.normalBuffer = normalBuffer;
                    this.uVBuffer = uVBuffer;
                    this.indexBuffer = indexBuffer;
                }
                agregarHijo (h) 
                {
                    this.hijos.push(h);
                }
                quitarHijo (h) 
                {
                    var indice = this.hijos.indexOf(h);
                    if (indice != -1)
                    {
                        this.hijos = this.hijos.splice(indice,1);
                    }
                }
                setPosicion (x,y,z) 
                {
                    vec3.set(this.posicion,x,y,z);
                }
                setRotacion (x,y,z,alfa) 
                {
                    vec3.set(this.rotacionEje,x,y,z);
                    this.rotacionAngulo = alfa;
                }
                setColor(r,g,b)
                {

                }
                setEscala (x,y,z) 
                {
                    vec3.set(this.escala,x,y,z);
                }
            }
            
            function inicializarObjetos()
            {
                var recorrido1 = generarRecta(1);
                var nivel1 = generarArcoCircunferencia(0.2,100);
                var buffers1 = superficieBarridoCompleta(nivel1,recorrido1);

                var recorrido2 = generarArcoCircunferencia(0,100,180);
                var nivel2= generarArcoCircunferencia(1,100);
                var buffers2 = superficieBarridoCompleta(nivel2,recorrido2);

                objetos3D = new Objeto3D();
                objetos3D.setGeometria(buffers2.supBarridoVerticeBuffer,buffers2.supBarridoNormalBuffer,null,buffers2.supBarridoIndexBuffer);                  

                var esfera = new Objeto3D();
                esfera.setGeometria(buffers1.supBarridoVerticeBuffer,buffers1.supBarridoNormalBuffer,null,buffers1.supBarridoIndexBuffer);
                esfera.setPosicion(-2.0,0.0,0.0);

                objetos3D.agregarHijo(esfera);

                                
            }

            /*
            *
            *
            * 
            * 
            * 
            */
            function setupVertexShaderMatrix(){
                var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");
                var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                gl.uniformMatrix4fv(modelMatrixUniform, false, modelMatrix);
                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
                gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            } 
            
            function setupVertexShaderMatrix2(){
                //var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");
                //var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                //gl.uniformMatrix4fv(modelMatrixUniform, false, modelMatrix);
                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
                //gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            }       
            
            function drawScene()
            {
                setupVertexShaderMatrix();
                /*
                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, bezierVerticeBuffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, bezierNormalBuffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bezierIndexBuffer);
                gl.drawElements( gl.LINE_STRIP, bezierIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                */

                /*
                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, trianglesNormalBuffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trianglesIndexBuffer);
                gl.drawElements( gl.TRIANGLE_STRIP, trianglesIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                */

                /*
                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, sBVerticeBuffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, sBNormalBuffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sBIndexBuffer);
                gl.drawElements( gl.TRIANGLE_STRIP, sBIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                */
                
                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffersSupBarrido.supBarridoVerticeBuffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffersSupBarrido.supBarridoNormalBuffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffersSupBarrido.supBarridoIndexBuffer);
                gl.drawElements( gl.TRIANGLE_STRIP, buffersSupBarrido.supBarridoIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                
                //gl.drawElements( gl.LINE_STRIP, sBIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);

            }

            function animate(){
                
                rotate_angle += 0.01;
                mat4.identity(modelMatrix);
                //mat4.rotate(modelMatrix,modelMatrix, rotate_angle, [1.0, 0.0, 1.0]);
                //mat4.identity(viewMatrix);
                //mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
                //mat4.rotate(viewMatrix,viewMatrix, rotate_angle, [-1.0, 0.0, 0.0]);


                mat4.identity(normalMatrix);
                mat4.multiply(normalMatrix,viewMatrix,modelMatrix);
                mat4.invert(normalMatrix,normalMatrix);
                mat4.transpose(normalMatrix,normalMatrix);

            }
            
            function tick(){

                requestAnimationFrame(tick);
                setupVertexShaderMatrix2();

                objetos3D.dibujar(viewMatrix);

                rotate_angle += 0.01;
                
                objetos3D.setRotacion(0,-1,0,rotate_angle);

                //mat4.identity(viewMatrix);
                //mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
                //mat4.rotate(viewMatrix,viewMatrix, rotate_angle, [0.0, -1.0, 0.0]);


                //drawScene();
                //animate();
            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
