<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: rgb(9, 0, 31); }
			textarea{ background-color: black; foreground-color: white;}

            #contenedor3d{
                position: relative;
                width: 100%;
                height: 100%;
                border: 1px solid black;
                margin: auto;
            }
        </style>
    </head>
    <body>
        <div id="contenedor3d">
            <center>    		            
                <canvas id="my-canvas" width="1000" height="700">
                    Your browser does not support the HTML5 canvas element.
                </canvas>    		
            </center>
        </div>

        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script src="js/bezier.js" type="module"></script>
        <script src="js/jquery.js"></script>
        <script src="js/dat.gui.js"></script>
        
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                vNormal = normalize(vNormal);
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            uniform vec3 colorDifuso;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                //vec3 diffColor=mix(colorDifuso,vNormal,0.4);
                //vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);
                vec3 color=dot(lightVec,vNormal)*colorDifuso;+vec3(0.2,0.2,0.2);

                //gl_FragColor = vec4(vNormal,1.0); 
                gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script>


            var mat4=glMatrix.mat4;
            var vec3=glMatrix.vec3;
            var vec4=glMatrix.vec4;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            trianglesIndexBuffer = null;
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();
            var rotate_angle = -1.57078;

            var buffersSupBarrido;

            // clases
            class Objeto3D
            {
                // atributos privados
                constructor()
                {
                    //buffers
                    this.vertexBuffer = null;
                    this.normalBuffer = null;
                    this.uVBuffer = null;
                    this.indexBuffer = null;
                    //matricex
                    this.matrizModelado = mat4.create();
                    this.matrizNormal = mat4.create();
                    // parametros
                    this.posicion =vec3.create();
                    this.rotacionEje = vec3.create();
                    this.rotacionAngulo = 0;
                    this.escala = vec3.fromValues(1,1,1);
                    this.color = vec3.fromValues(0.0,0.2,0.8);
                    // hijos
                    this.hijos = [];
                } 
                // método privado, usa posición, rotación y escala
                actualizarMatrizModelado()
                {
                    mat4.identity(this.matrizModelado);
                    mat4.translate(this.matrizModelado,this.matrizModelado,this.posicion);
                    mat4.rotate(this.matrizModelado,this.matrizModelado,this.rotacionAngulo,this.rotacionEje);
                    mat4.scale(this.matrizModelado,this.matrizModelado,this.escala);
                    //console.log(this.matrizModelado);
                }
                
                actualizarMatrizNormal(matrizVista,matrizM)
                {
                    mat4.multiply(this.matrizNormal,matrizVista,matrizM);
                    mat4.invert(this.matrizNormal,this.matrizNormal);
                    mat4.transpose(this.matrizNormal,this.matrizNormal);
                }
                // métodos públicos
                dibujar (matrizVista, matrizPadre = null)
                {
                    var m = mat4.create();
                    this.actualizarMatrizModelado();
                    
                    // concatenamos las transformaciones padre/hijo
                    if(matrizPadre)
                        mat4.multiply(m, matrizPadre, this.matrizModelado);
                    else
                        mat4.copy(m, this.matrizModelado)

                    this.actualizarMatrizNormal(matrizVista, m);

                    if(this.vertexBuffer && this.indexBuffer)
                    {
                    // setear matrices modelado y normales
                    var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
                    var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");
                    var colorDifusoUniform  = gl.getUniformLocation(glProgram, "colorDifuso");

                    gl.uniformMatrix4fv(modelMatrixUniform, false, m);
                    gl.uniformMatrix4fv(normalMatrixUniform, false, this.matrizNormal);
                    gl.uniform3fv(colorDifusoUniform, this.color);

                    //setear buffers    
                    vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                    gl.enableVertexAttribArray(vertexPositionAttribute);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                    vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                    gl.enableVertexAttribArray(vertexNormalAttribute);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
                    gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    gl.drawElements( gl.TRIANGLE_STRIP, this.indexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                    }

                    for(var i=0;i< this.hijos.length;i++)
                    {
                        this.hijos[i].dibujar(matrizVista, m);
                    } 
                }
                
                setGeometria (vertexBuffer,normalBuffer,uVBuffer,indexBuffer)
                {
                    this.vertexBuffer = vertexBuffer;
                    this.normalBuffer = normalBuffer;
                    this.uVBuffer = uVBuffer;
                    this.indexBuffer = indexBuffer;
                }
                
                setGeometria (buffers)
                {
                    this.vertexBuffer = buffers.supBarridoVerticeBuffer;
                    this.normalBuffer = buffers.supBarridoNormalBuffer;
                    this.uVBuffer = buffers.supBarridoUVBuffer;
                    this.indexBuffer = buffers.supBarridoIndexBuffer;
                }
                
                agregarHijo (h) 
                {
                    this.hijos.push(h);
                }
                
                quitarHijo (h) 
                {
                    var indice = this.hijos.indexOf(h);
                    if (indice != -1)
                    {
                        this.hijos.splice(indice,1);
                    }
                }
                
                setPosicion (x,y,z) 
                {
                    vec3.set(this.posicion,x,y,z);
                }
                
                setRotacion (x,y,z,alfa) 
                {
                    vec3.set(this.rotacionEje,x,y,z);
                    this.rotacionAngulo = alfa;
                }
                
                setColor(r,g,b)
                {
                    vec3.set(this.color,r,g,b);
                }
                
                setEscala (x,y,z) 
                {
                    vec3.set(this.escala,x,y,z);
                }
            }
            
            class Camara
            {
                constructor()
                {
                    //buffers
                    this.radio = 1;
                    this.phi = 0;
                    this.theta = Math.PI/2;
                    this.thetaMin = 0+0.00001;
                    this.thetaMax = Math.PI-0.00001;
                    this.matrizVista = mat4.create();
                    this.centro = vec3.create();
                    this.up = vec3.fromValues(0,1,0);

                } 
                // metodos privados


                // métodos públicos
                setRadio(radio)
                {
                    this.radio = radio;
                }

                getRadio()
                {
                    return this.radio;
                }
                
                setPhi(phi)
                {
                    this.phi = phi;
                }

                getPhi()
                {
                    return this.phi;
                }

                setTheta(theta)
                {
                    this.theta = theta;
                    if(theta > this.thetaMax)
                        this.theta = this.thetaMax;
                    if(theta < this.thetaMin)
                        this.theta = this.thetaMin;
                }

                getTheta()
                {
                    return this.theta;
                }

                getMatrizVista()
                {
                    return this.matrizVista;
                }

                dibujar (matrizVista, matrizPadre = null)
                {
                    mat4.getTranslation(this.centro,matrizPadre)
                    var centroCamara = vec3.fromValues(this.radio*Math.sin(this.phi)*Math.sin(this.theta),this.radio*Math.cos(this.theta),this.radio*Math.cos(this.phi)*Math.sin(this.theta));
                    vec3.transformMat4(centroCamara,centroCamara,matrizPadre);
                    //vec3.add(centroCamara,centroCamara,this.centro)
                    mat4.lookAt(this.matrizVista,centroCamara,this.centro,this.up);
                }
            }
            
            class Movil
            {
                constructor()
                {
                    //matricex
                    this.matrizModelado = mat4.create();
                    this.matrizRotacion = mat4.create();
                    mat4.identity(this.matrizRotacion);
                    this.matrizAuxiliar = mat4.create();
                    // parametros
                    this.vecAdelanteOriginal = vec3.fromValues(0,0,1);
                    this.vecArribaOriginal = vec3.fromValues(0,1,0);
                    this.vecLateralOriginal = vec3.fromValues(1,0,0);
                    this.posicion = vec3.create();
                    this.vecAdelante = vec3.fromValues(0,0,1);
                    this.vecArriba = vec3.fromValues(0,1,0);
                    this.vecLateral = vec3.fromValues(1,0,0);
                    // auxiliares
                    this.vecAdelanteAux = vec3.create();
                    this.vecArribaAux = vec3.create();
                    this.vecLateralAux = vec3.create();
                    // hijos
                    this.hijos = [];
                } 

                actualizarMatrizModelado()
                {
                    mat4.identity(this.matrizModelado);
                    mat4.translate(this.matrizModelado,this.matrizModelado,this.posicion);
                    mat4.multiply(this.matrizModelado,this.matrizModelado,this.matrizRotacion);
                }

                dibujar (matrizVista, matrizPadre = null)
                {
                    var m = mat4.create();
                    this.actualizarMatrizModelado();
                    
                    // concatenamos las transformaciones padre/hijo
                    if(matrizPadre)
                        mat4.multiply(m, matrizPadre, this.matrizModelado);
                    else
                        mat4.copy(m, this.matrizModelado)

                    for(var i=0;i< this.hijos.length;i++)
                    {
                        this.hijos[i].dibujar(matrizVista, m);
                    } 
                }

                agregarHijo (h) 
                {
                    this.hijos.push(h);
                }
                
                quitarHijo (h) 
                {
                    var indice = this.hijos.indexOf(h);
                    if (indice != -1)
                    {
                        this.hijos.splice(indice,1);
                    }
                }

                setPosicion (x,y,z) 
                {
                    vec3.set(this.posicion,x,y,z);
                }

                moverHaciaAdelante(distancia)
                {
                    vec3.scaleAndAdd(this.posicion,this.posicion,this.vecAdelante,distancia);
                }

                moverHaciaArriba(distancia)
                {
                    vec3.scaleAndAdd(this.posicion,this.posicion,this.vecArriba,distancia);
                }

                moverHaciaLaIzquierda(distancia)
                {
                    vec3.scaleAndAdd(this.posicion,this.posicion,this.vecLateral,distancia);
                }

                girarAnguloAlabeo(angulo)
                {
                    mat4.identity(this.matrizAuxiliar);
                    mat4.rotate(this.matrizAuxiliar,this.matrizAuxiliar,angulo,this.vecAdelante);
                    mat4.multiply(this.matrizRotacion,this.matrizAuxiliar,this.matrizRotacion);
                    //mat4.rotate(this.matrizModelado,this.matrizModelado,angulo,this.vecAdelanteOriginal);
                    //mat4.multiply(this.matrizRotacion,this.matrizRotacion,this.matrizModelado);


                    var sin = Math.sin(angulo);
                    var cos = Math.cos(angulo);

                    vec3.scale(this.vecArribaAux,this.vecArriba,cos);
                    vec3.scaleAndAdd(this.vecArribaAux,this.vecArribaAux,this.vecLateral,-sin);

                    vec3.scale(this.vecLateralAux,this.vecLateral,cos);
                    vec3.scaleAndAdd(this.vecLateralAux,this.vecLateralAux,this.vecArribaAux,sin);

                    vec3.copy(this.vecLateral,this.vecLateralAux);
                    vec3.normalize(this.vecLateral,this.vecLateral);
                    vec3.copy(this.vecArriba,this.vecArribaAux);
                    vec3.normalize(this.vecArriba,this.vecArriba);
                }

                girarAnguloGuiniada(angulo)
                {
                    mat4.identity(this.matrizAuxiliar);
                    mat4.rotate(this.matrizAuxiliar,this.matrizAuxiliar,angulo,this.vecArriba);
                    mat4.multiply(this.matrizRotacion,this.matrizAuxiliar,this.matrizRotacion);
                    //mat4.rotate(this.matrizAuxiliar,this.matrizAuxiliar,angulo,this.vecArribaOriginal);
                    //mat4.multiply(this.matrizRotacion,this.matrizRotacion,this.matrizAuxiliar);
                    
                    var sin = Math.sin(angulo);
                    var cos = Math.cos(angulo);

                    vec3.scale(this.vecAdelanteAux,this.vecAdelante,cos);
                    vec3.scaleAndAdd(this.vecAdelanteAux,this.vecAdelanteAux,this.vecLateral,sin);

                    vec3.scale(this.vecLateralAux,this.vecLateral,cos);
                    vec3.scaleAndAdd(this.vecLateralAux,this.vecLateralAux,this.vecAdelanteAux,-sin);

                    vec3.copy(this.vecLateral,this.vecLateralAux);
                    vec3.normalize(this.vecLateral,this.vecLateral);
                    vec3.copy(this.vecAdelante,this.vecAdelanteAux);
                    vec3.normalize(this.vecAdelante,this.vecAdelante);
                    
                }

                girarAnguloCabeceo(angulo)
                {
                    mat4.identity(this.matrizAuxiliar);
                    mat4.rotate(this.matrizAuxiliar,this.matrizAuxiliar,angulo,this.vecLateral);
                    mat4.multiply(this.matrizRotacion,this.matrizAuxiliar,this.matrizRotacion);
                    //mat4.rotate(this.matrizAuxiliar,this.matrizAuxiliar,angulo,this.vecLateralOriginal);
                    //mat4.multiply(this.matrizRotacion,this.matrizRotacion,this.matrizAuxiliar);

                    var sin = Math.sin(angulo);
                    var cos = Math.cos(angulo);
                    
                    vec3.scale(this.vecAdelanteAux,this.vecAdelante,cos);
                    vec3.scaleAndAdd(this.vecAdelanteAux,this.vecAdelanteAux,this.vecArriba,-sin);

                    vec3.scale(this.vecArribaAux,this.vecArriba,cos);
                    vec3.scaleAndAdd(this.vecArribaAux,this.vecArribaAux,this.vecAdelanteAux,sin);

                    vec3.copy(this.vecArriba,this.vecArribaAux);
                    vec3.normalize(this.vecArriba,this.vecArriba);
                    vec3.copy(this.vecAdelante,this.vecAdelanteAux);
                    vec3.normalize(this.vecAdelante,this.vecAdelante);
                    
                }
            }
            // mis variables globales

            var objetos3D;

            var camara1 = new Camara();
            var camara2 = new Camara();
            var camara3 = new Camara();
            var camaraElegida = camara1;
            const pasoRadioC1 = 0.2;
            const pasoAnguloC1 = 0.01;
            const pasoRadioC3 = 0;
            const pasoAnguloC3 = 0;
            var pasoRadio = pasoRadioC1;
            var pasoAngulo = pasoAnguloC1;

            // dat.gui
            var punteroPaneles;
            var punteroAnillo;
            var punteroEstacionEspacial;
            var punteroModuloPanelesSolares;
            var punteroPadrePanelesSolares;

            var variablesGUI = {
                cantidadModulos: 5,
                angulosPaneles: 0,
                cantidadFilasPaneles: 4,
                velocidadAnillo: 0
            };
            var anguloAnillo = 0;    
            
            var cantidadModulosActual = variablesGUI.cantidadModulos;
            var cantidadFilasPanelesActual = variablesGUI.cantidadFilasPaneles;
            
            const gui = new dat.GUI();

            // jquery
            var isMouseDown = false;
            var mouse = {x: 0, y: 0};
            var previousClientX;
            var previousClientY;
            var ruedaMouse;

            // movimiento capsula;
            const pasoAnguloCapsula = 0.1;
            const pasoDistaciaCapsula = 0.1;
            var capsula;
         
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {

                    setupWebGL();
                    initShaders();
                    setupBuffers();
                    probarSuperficieDeBarrido();
                    setupVertexShaderMatrix();
                    inicializarObjetos();
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 100.0);
                
                mat4.identity(modelMatrix);
                mat4.rotate(modelMatrix,modelMatrix, -1.57078, [1.0, 0.0, 0.0]);

                mat4.identity(viewMatrix);
                let alfa = 0;
                let x = 0.0;
                let y = 5.0*Math.sin(alfa*Math.PI/180);
                let z = 5.0*Math.cos(alfa*Math.PI/180);
                //mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
                mat4.lookAt(viewMatrix,[x,y,z],[0,0,0],[0,1,0]);
            }
                    
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }
            
            function getPos(alfa,beta){

                var r=2;
                var nx=Math.sin(beta)*Math.sin(alfa);
                var ny=Math.sin(beta)*Math.cos(alfa);
                var nz=Math.cos(beta);


                var g=beta%0.5;
                var h=alfa%1;
                var f=1;

                if (g<0.25) f=0.95;
                if (h<0.5) f=f*0.95;
                
                var x=nx*r*f;
                var y=ny*r*f;
                var z=nz*r*f;

                return [x,y,z];
            }

            function getNrm(alfa,beta){
                var p=getPos(alfa,beta);
                var v=vec3.create();
                vec3.normalize(v,p);

                var delta=0.05;
                var p1=getPos(alfa,beta);
                var p2=getPos(alfa,beta+delta);
                var p3=getPos(alfa+delta,beta);

                var v1=vec3.fromValues(p2[0]-p1[0],p2[1]-p1[1],p2[2]-p1[2]);
                var v2=vec3.fromValues(p3[0]-p1[0],p3[1]-p1[1],p3[2]-p1[2]);

                vec3.normalize(v1,v1);
                vec3.normalize(v2,v2);
                
                var n=vec3.create();
                vec3.cross(n,v1,v2);
                vec3.scale(n,n,-1);
                return n;
            }

            function setupBuffers()
            {
                var pos=[];
                var normal=[];
                var r=2;
                var rows=128;
                var cols=256;

                for (var i=0;i<rows;i++){
                    for (var j=0;j<cols;j++){

                        var alfa=j/(cols-1)*Math.PI*2;
                        var beta=(0.1+i/(rows-1)*0.8)*Math.PI;

                        var p=getPos(alfa,beta);

                        pos.push(p[0]);
                        pos.push(p[1]);
                        pos.push(p[2]);

                        var n=getNrm(alfa,beta);

                        normal.push(n[0]);
                        normal.push(n[1]);
                        normal.push(n[2]);
                    }

                }
      
                trianglesVerticeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);    
            

                trianglesNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, trianglesNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW);

                var index=[];

                for (var i=0;i<rows-1;i++){
                    index.push(i*cols);
                    for (var j=0;j<cols-1;j++){
                        index.push(i*cols+j);
                        index.push((i+1)*cols+j);
                        index.push(i*cols+j+1);
                        index.push((i+1)*cols+j+1);
                    }
                    index.push((i+1)*cols+cols-1);
                }
                
                
                trianglesIndexBuffer = gl.createBuffer();
                trianglesIndexBuffer.number_vertex_point = index.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trianglesIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(index), gl.STATIC_DRAW);    
            }

            /*
            *
            *
            */
            function bezierRecursivo(puntosDeControl, u, grado)
            {

                var puntosNuevos = [];

                var xm;
                var ym;
                var zm;


                for (var i = 0; i < grado; i++) 
                {
                    xm = (1-u)*puntosDeControl[3*(i)] + u*puntosDeControl[3*(i+1)];
                    ym = (1-u)*puntosDeControl[3*(i)+1] + u*puntosDeControl[3*(i+1)+1];
                    zm = (1-u)*puntosDeControl[3*(i)+2] + u*puntosDeControl[3*(i+1)+2];

                    puntosNuevos.push(xm);
                    puntosNuevos.push(ym);
                    puntosNuevos.push(zm);
                }

                if(grado <= 1)
                {
                    xm = puntosDeControl[3] - puntosDeControl[0];
                    ym = puntosDeControl[4] - puntosDeControl[1];
                    zm = puntosDeControl[5] - puntosDeControl[2];
                    var vectorTangente = vec3.fromValues(xm,ym,zm);
                    vec3.normalize(vectorTangente, vectorTangente);


                    return {
                        puntosNuevos,
                        vectorTangente
                    };
                }
                else 
                {
                    return bezierRecursivo(puntosNuevos, u, grado-1);
                }
                
            }

            function calcularBinormal(puntos)
            {
                var longitud = puntos.length;

                var v1 = vec3.fromValues(puntos[longitud-3],puntos[longitud-2],puntos[longitud-1]);
                var v2 = vec3.fromValues(puntos[longitud-6],puntos[longitud-5],puntos[longitud-4]);
                var v3 = vec3.fromValues(puntos[longitud-9],puntos[longitud-8],puntos[longitud-7]);


                var v12 = vec3.create();
                var v23 = vec3.create();
                var binormal = vec3.create();

                var normal = vec3.create();
                var v32 = vec3.create();

                vec3.sub(v12,v1,v2);
                vec3.sub(v23,v2,v3);

                vec3.cross(binormal,v12,v23);
                //vec3.cross(binormal,v23,v12);
                

                vec3.normalize(binormal, binormal);


                // harcodeo binormal eje z
                //vec3.set(binormal,0.0,0.0,1.0);

                return binormal;

            }

            function bezier(puntosDeControl, cantidadPuntosFinal, grado)
            {

                // iteracion -1
                var paso = 1.0/(cantidadPuntosFinal-1);
                var puntoBezier = bezierRecursivo(puntosDeControl, -paso, grado)



                var posicion = puntoBezier.puntosNuevos;
                var tangente = [];
                var normal = [];
                var binormal = [];

                var tangenteActual;
                var binormalActual;
                var normalActural = vec3.create();

                // itracion 0

                puntoBezier = bezierRecursivo(puntosDeControl, 0.0, grado);
                posicion.push(puntoBezier.puntosNuevos[0]);
                posicion.push(puntoBezier.puntosNuevos[1]);
                posicion.push(puntoBezier.puntosNuevos[2]);

                tangenteActual = puntoBezier.vectorTangente;

                tangente.push(tangenteActual[0]);
                tangente.push(tangenteActual[1]);
                tangente.push(tangenteActual[2]);

                for (var i = 1; i<cantidadPuntosFinal+1; i++)
                {
                    puntoBezier = bezierRecursivo(puntosDeControl, i*paso, grado);
                    posicion.push(puntoBezier.puntosNuevos[0]);
                    posicion.push(puntoBezier.puntosNuevos[1]);
                    posicion.push(puntoBezier.puntosNuevos[2]);

                    binormalActual = calcularBinormal(posicion);
                    vec3.cross(normalActural,tangenteActual,binormalActual);
                    //vec3.cross(normalActural,binormalActual,tangenteActual);
                    vec3.normalize(normalActural,normalActural)

                    normal.push(normalActural[0]);
                    normal.push(normalActural[1]);
                    normal.push(normalActural[2]);

                    binormal.push(binormalActual[0]);
                    binormal.push(binormalActual[1]);
                    binormal.push(binormalActual[2]);

                    tangenteActual = puntoBezier.vectorTangente;

                    tangente.push(tangenteActual[0]);
                    tangente.push(tangenteActual[1]);
                    tangente.push(tangenteActual[2]);
                }

                // elimino primer y último punto
                // elimino última tangente

                posicion.pop();
                posicion.pop();
                posicion.pop();

                posicion.shift();
                posicion.shift();
                posicion.shift();

                tangente.pop();
                tangente.pop();
                tangente.pop();

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal
                };

            }

            function bezier2D(puntosDeControl, cantidadPuntosFinal, grado)
            {

                var paso = 1.0/(cantidadPuntosFinal-1);
                var puntoBezier
                
                var posicion = []
                var tangente = [];
                var normal = [];
                var binormal = [];

                var tangenteActual;
                var binormalActual;
                var normalActural = vec3.create();

                for (var i = 0; i<cantidadPuntosFinal; i++)
                {
                    puntoBezier = bezierRecursivo(puntosDeControl, i*paso, grado);
                    posicion.push(puntoBezier.puntosNuevos[0],puntoBezier.puntosNuevos[1],puntoBezier.puntosNuevos[2]);
                    tangenteActual = puntoBezier.vectorTangente;

                    tangente.push(tangenteActual[0],tangenteActual[1],tangenteActual[2]);

                    binormalActual = [0,0,-1];
                    binormal.push(binormalActual[0],binormalActual[1],binormalActual[2]);

                    vec3.cross(normalActural,tangenteActual,binormalActual);
                    vec3.normalize(normalActural,normalActural)
                    normal.push(normalActural[0],normalActural[1],normalActural[2]);
                }

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal
                };
            }
            
            function bezierCompleto(puntosControl,cantidadPuntosFinalTotal, grado)
            {
                var cantidadCurvas = Math.floor(puntosControl.length/(3*(grado+1)));
                var cantidadPuntosPorCurva = Math.ceil(cantidadPuntosFinalTotal/cantidadCurvas);
                var cantidadPuntosFinal = cantidadPuntosPorCurva*cantidadCurvas;

                var posicion = [];
                var tangente = [];
                var normal = [];
                var binormal = [];

                var puntosControlUsados;
                var bezier2;

                for(var i = 0; i<cantidadCurvas; i++)
                {
                    puntosControlUsados = puntosControl.slice(3*(grado+1)*i,3*(grado+1)*(i+1));
                    bezier2 = bezier(puntosControlUsados, cantidadPuntosPorCurva, grado);
                    posicion = posicion.concat(bezier2.posicion);
                    tangente = tangente.concat(bezier2.tangente);
                    normal = normal.concat(bezier2.normal);
                    binormal = binormal.concat(bezier2.binormal);
                }

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };

            }

            function bezierCompleto2D(puntosControl,cantidadPuntosFinalTotal, grado)
            {
                var cantidadCurvas = Math.floor(puntosControl.length/(3*(grado+1)));
                var cantidadPuntosPorCurva = Math.ceil(cantidadPuntosFinalTotal/cantidadCurvas);
                var cantidadPuntosFinal = cantidadPuntosPorCurva*cantidadCurvas;

                var posicion = [];
                var tangente = [];
                var normal = [];
                var binormal = [];

                var puntosControlUsados;
                var bezier2;

                for(var i = 0; i<cantidadCurvas; i++)
                {
                    puntosControlUsados = puntosControl.slice(3*(grado+1)*i,3*(grado+1)*(i+1));
                    bezier2 = bezier2D(puntosControlUsados, cantidadPuntosPorCurva, grado);
                    posicion = posicion.concat(bezier2.posicion);
                    tangente = tangente.concat(bezier2.tangente);
                    normal = normal.concat(bezier2.normal);
                    binormal = binormal.concat(bezier2.binormal);
                }

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };

            }


            function calcularValorBufferUVSuperficie(posicionesUoV, cantidadPuntosUoV)
            {
                var tablaPosiciones = [0];
                var puntoAnterior= vec3.create();
                var puntoSiguiente = vec3.fromValues(posicionesUoV[0],posicionesUoV[1],posicionesUoV[2]);
                var distancia;
                var max;
                for(var i = 1; i < cantidadPuntosUoV; i++)
                {
                    vec3.copy(puntoAnterior,puntoSiguiente);
                    vec3.set(puntoSiguiente,posicionesUoV[3*(i-1)],posicionesUoV[3*(i-1)+1],posicionesUoV[3*(i-1)+2]);
                    distancia = vec3.distance(puntoAnterior, puntoSiguiente);
                    tablaPosiciones.push(tablaPosiciones[i-1]+distancia);
                }
                max = tablaPosiciones[cantidadPuntosUoV-1];
                for(var i = 0; i < cantidadPuntosUoV; i++)
                {
                    tablaPosiciones[i] = tablaPosiciones[i]/max;
                }
                return tablaPosiciones;
            }

            function obtenerMatricesTransformacion(recorrido, matrizRotoEscalado, punto)
            {
                var normal = recorrido.normal;
                var posicion = recorrido.posicion;
                var tangente = recorrido.tangente;
                var binormal = recorrido.binormal;

                var a = [];

                a.push(normal[3*punto]);
                a.push(normal[3*punto+1]);
                a.push(normal[3*punto+2]);
                a.push(0);
                a.push(binormal[3*punto]);
                a.push(binormal[3*punto+1]);
                a.push(binormal[3*punto+2]);
                a.push(0);
                a.push(tangente[3*punto]);
                a.push(tangente[3*punto+1]);
                a.push(tangente[3*punto+2]);
                a.push(0);
                a.push(posicion[3*punto]);
                a.push(posicion[3*punto+1]);
                a.push(posicion[3*punto+2]);
                a.push(1);

                var matrizModelado = mat4.fromValues(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]);
                mat4.multiply(matrizModelado, matrizModelado, matrizRotoEscalado);
                var matrizNormal = mat4.create();
                
                mat4.invert(matrizNormal,matrizModelado);
                mat4.transpose(matrizNormal,matrizNormal);
                
                return{
                    matrizModelado,
                    matrizNormal
                };
            }

            function obtnerMatrixRotoEscalado(escalados,angulosRotacion,vectoresRotacion, paso)
            {
                var matrixRotoEscalado = mat4.create();
                var vectorRotacion;
                var vectorEscalado;
                mat4.identity(matrixRotoEscalado);
                if (angulosRotacion != null)
                {
                    vectorRotacion = vec3.fromValues(vectoresRotacion[0],vectoresRotacion[1],vectoresRotacion[2])
                    mat4.rotate(matrixRotoEscalado,matrixRotoEscalado,angulosRotacion[paso],vectorRotacion);
                }
                if (escalados != null)
                {
                    vectorEscalado = vec3.fromValues(escalados[3*paso],escalados[3*paso+1],escalados[3*paso+2])
                    mat4.scale(matrixRotoEscalado,matrixRotoEscalado,vectorEscalado);
                }
                return matrixRotoEscalado;
            }

            function obtenerTransformacionNivel(nivel, matrizModelado, matrizNormal, bufferU, valorV)
            {
                var bufferPuntos = [];
                var bufferNormales = [];
                var bufferUV = [];
                var punto = vec3.create();
                var normal = vec4.create();
                var normalAux = vec3.create();
                for(var i = 0; i<nivel.cantidadPuntosFinal; i++)
                {   
                    vec3.set(punto,nivel.posicion[3*i],nivel.posicion[3*i+1],nivel.posicion[3*i+2]);
                    vec4.set(normal,nivel.normal[3*i],nivel.normal[3*i+1],nivel.normal[3*i+2],1);
                    vec3.transformMat4(punto,punto,matrizModelado);
                    vec4.transformMat4(normal,normal,matrizNormal);
                    //invierto signo normal
                    vec4.scale(normal,normal,-1);
                    vec3.set(normalAux,normal[0],normal[1],normal[2]);
                    vec3.normalize(normalAux,normalAux);
                    bufferPuntos.push(punto[0],punto[1],punto[2]);
                    bufferNormales.push(normalAux[0],normalAux[1],normalAux[2]);
                    bufferUV.push(bufferU[i],valorV);
                }
                return{
                    bufferPuntos,
                    bufferNormales,
                    bufferUV
                };
            }

            function obtenerIndexBuffer(cantidadFilas, cantidadColumnas)
            {
                var indexBuffer=[];  
                //indexBuffer=[0,1,2,2,1,3]; // Estos valores iniciales harcodeados solo dibujan 2 triangulos, REMOVER ESTA LINEA!

                var verticeSuperior;
                var verticeinferior;
                
                for (i=0; i < cantidadFilas-1; i++) {
                    verticeSuperior = i*(cantidadColumnas);
                    verticeinferior = (i+1)*(cantidadColumnas);
                    for (j=0; j < cantidadColumnas-1; j++) {

                        indexBuffer.push(verticeSuperior);
                        indexBuffer.push(verticeinferior);

                        verticeSuperior = verticeSuperior + 1;
                        verticeinferior = verticeinferior + 1;
                        
                    }

                    // oara el cambio de linea
                    indexBuffer.push(verticeSuperior);
                    indexBuffer.push(verticeinferior);

                    indexBuffer.push(verticeinferior);
                    indexBuffer.push((i+1)*(cantidadColumnas));

                    
                }
                return indexBuffer;
            }

            function calcularValorBufferUVTapas(posicionesTapa, cantidadPuntos)
            {
                var bufferUVBorde = [];
                var bufferUVCentro = [];
                var xmax = posicionesTapa[0];
                var xmin = xmax;
                var ymax = posicionesTapa[1];
                var ymin = ymax;
                var xaux;
                var yaux;
                var xpromedio = xmax;
                var ypromedio = ymax;

                for(var i = 1; i < cantidadPuntos; i++)
                {
                    xaux = posicionesTapa[3*i];
                    yaux = posicionesTapa[3*i+1];
                    xpromedio += xaux;
                    ypromedio += yaux;
                    if(xaux > xmax)
                    {
                        xmax = xaux;
                    }
                    if(xaux < xmin)
                    {
                        xmin = xaux;
                    }
                    if(yaux > ymax)
                    {
                        ymax = yaux;
                    }
                    if(yaux < ymin)
                    {
                        ymin = yaux;
                    }
                }
                xpromedio = xpromedio/cantidadPuntos;
                ypromedio = ypromedio/cantidadPuntos;
                var xdif = xmax-xmin;
                var ydif = ymax-ymin;

                xaux = xpromedio - xmin;
                xpromedio = xaux/xdif;
                yaux = ypromedio - ymin;
                ypromedio = yaux/ydif;

                for(var i = 0; i < cantidadPuntos; i++)
                {
                    xaux = posicionesTapa[3*i] - xmin;
                    xaux = xaux/xdif;
                    yaux = posicionesTapa[3*i+1] - ymin;
                    yaux = yaux/ydif;
                    bufferUVBorde.push(xaux);
                    bufferUVBorde.push(yaux);
                    bufferUVCentro.push(xpromedio);
                    bufferUVCentro.push(ypromedio);
                }
                return{
                    bufferUVBorde,
                    bufferUVCentro
                };
                  
            }

            function generarSuperficieDeBarrido(nivel,recorrido,escalados = null,angulosRotacion = null)
            {
                var nivelNuevo;
                var matrices;
                var matrizRotoEscalado;

                var bufferPuntos = [];
                var bufferNormales = [];
                var bufferUV = [];
                var bufferIndices;

                var bufferU = calcularValorBufferUVSuperficie(nivel.posicion,nivel.cantidadPuntosFinal);
                var bufferV = calcularValorBufferUVSuperficie(recorrido.posicion,recorrido.cantidadPuntosFinal);

                var vectorTangente = [nivel.binormal[0],nivel.binormal[1],nivel.binormal[2]];
                //var vectorTangente = [nivel.normal[0],nivel.normal[1],nivel.normal[2]];
                for (var i = 0; i < recorrido.cantidadPuntosFinal; i++) 
                
                {
                    matrizRotoEscalado = obtnerMatrixRotoEscalado(escalados, angulosRotacion, vectorTangente, i);
                    matrices = obtenerMatricesTransformacion(recorrido, matrizRotoEscalado, i);    
                    nivelNuevo = obtenerTransformacionNivel(nivel, matrices.matrizModelado, matrices.matrizNormal, bufferU, bufferV[i]);
                    bufferPuntos = bufferPuntos.concat(nivelNuevo.bufferPuntos);
                    bufferNormales = bufferNormales.concat(nivelNuevo.bufferNormales);
                    bufferUV = bufferUV.concat(nivelNuevo.bufferUV);
                    
                }
                bufferIndices = obtenerIndexBuffer(recorrido.cantidadPuntosFinal, nivel.cantidadPuntosFinal);

                return{
                    bufferPuntos,
                    bufferNormales,
                    bufferUV,
                    bufferIndices
                };

            }

            function superficieBarridoCompleta(nivel,recorrido,escalados = null,angulosRotacion = null,tapaInicial = true, tapaFinal = true)
            {
                var buffersSuperficie = generarSuperficieDeBarrido(nivel, recorrido, escalados, angulosRotacion);
                var tangenteRecorrido;
                var centroTapaX = 0;
                var centroTapaY = 0;
                var centroTapaZ = 0;
                var puntosTapa;
                var cantidadFilas = recorrido.cantidadPuntosFinal;
                var cantidadFilasFinal = cantidadFilas;
                var cantidadColumnas = nivel.cantidadPuntosFinal;
                var cantidadTotalPuntos = cantidadFilas*cantidadColumnas;


                var bufferPosicion = [];
                var bufferNormal = [];
                var bufferUV = [];
                var bufferIndice;

                var bufferUVAux = calcularValorBufferUVTapas(nivel.posicion, cantidadColumnas);
                
                if(tapaInicial)
                {
                    puntosTapa = buffersSuperficie.bufferPuntos.slice(0,3*cantidadColumnas);
                    tangenteRecorrido = recorrido.tangente.slice(0,3);
                    tangenteRecorrido = vec3.scale(tangenteRecorrido,tangenteRecorrido,-1);
                    //console.log(tangenteRecorrido);
                    centroTapaX = 0;
                    centroTapaY = 0;
                    centroTapaZ = 0;
                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        centroTapaX += puntosTapa[3*i];
                        centroTapaY += puntosTapa[3*i+1];
                        centroTapaZ += puntosTapa[3*i+2];
                        bufferNormal.push(tangenteRecorrido[0],tangenteRecorrido[1],tangenteRecorrido[2]);
                        bufferNormal.push(tangenteRecorrido[0],tangenteRecorrido[1],tangenteRecorrido[2]);
                    }
                    centroTapaX = centroTapaX/cantidadColumnas;
                    centroTapaY = centroTapaY/cantidadColumnas;
                    centroTapaZ = centroTapaZ/cantidadColumnas;

                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        bufferPosicion.push(centroTapaX,centroTapaY,centroTapaZ);
                    }
                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        bufferPosicion.push(puntosTapa[3*i],puntosTapa[3*i+1],puntosTapa[3*i+2]);
                    }
                    
                    bufferUV = bufferUV.concat(bufferUVAux.bufferUVCentro);
                    bufferUV = bufferUV.concat(bufferUVAux.bufferUVBorde);

                    cantidadFilasFinal += 2;
                }

                bufferPosicion = bufferPosicion.concat(buffersSuperficie.bufferPuntos);
                bufferNormal = bufferNormal.concat(buffersSuperficie.bufferNormales);
                bufferUV = bufferUV.concat(buffersSuperficie.bufferUV);

                if(tapaFinal)
                {
                    puntosTapa = buffersSuperficie.bufferPuntos.slice(3*(cantidadTotalPuntos-cantidadColumnas),3*cantidadTotalPuntos);
                    tangenteRecorrido = recorrido.tangente.slice(3*(cantidadFilas-1),3*cantidadFilas);
                    centroTapaX = 0;
                    centroTapaY = 0;
                    centroTapaZ = 0;
                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        centroTapaX += puntosTapa[3*i];
                        centroTapaY += puntosTapa[3*i+1];
                        centroTapaZ += puntosTapa[3*i+2];
                        bufferNormal.push(tangenteRecorrido[0],tangenteRecorrido[1],tangenteRecorrido[2]);
                        bufferNormal.push(tangenteRecorrido[0],tangenteRecorrido[1],tangenteRecorrido[2]);
                        bufferPosicion.push(puntosTapa[3*i],puntosTapa[3*i+1],puntosTapa[3*i+2]);                        
                    }
                    centroTapaX = centroTapaX/cantidadColumnas;
                    centroTapaY = centroTapaY/cantidadColumnas;
                    centroTapaZ = centroTapaZ/cantidadColumnas;

                    for(var i = 0; i < cantidadColumnas; i++ )
                    {
                        bufferPosicion.push(centroTapaX,centroTapaY,centroTapaZ);
                    }
                    bufferUV = bufferUV.concat(bufferUVAux.bufferUVBorde);
                    bufferUV = bufferUV.concat(bufferUVAux.bufferUVCentro);
                    cantidadFilasFinal += 2;
                }

                bufferIndice = obtenerIndexBuffer(cantidadFilasFinal,cantidadColumnas);

                var supBarridoVerticeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, supBarridoVerticeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bufferPosicion), gl.STATIC_DRAW);    
            

                var supBarridoNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, supBarridoNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bufferNormal), gl.STATIC_DRAW);

                var supBarridoUVBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, supBarridoUVBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bufferUV), gl.STATIC_DRAW);
 
                var supBarridoIndexBuffer = gl.createBuffer();
                supBarridoIndexBuffer.number_vertex_point = bufferIndice.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, supBarridoIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(bufferIndice), gl.STATIC_DRAW); 

                return {
                    supBarridoVerticeBuffer,
                    supBarridoNormalBuffer,
                    supBarridoUVBuffer,
                    supBarridoIndexBuffer
                };
            }

            function superficieRevolucionCompleta(nivel,recorrido,invertirNormalTapas = false,tapaInicial = true, tapaFinal = true,escalados = null,angulosRotacion = null)
            {
                
                if(tapaInicial)
                {
                    nivel.posicion.splice(0,0,nivel.posicion[0],nivel.posicion[1],nivel.posicion[2],nivel.posicion[0],nivel.posicion[1],nivel.posicion[2]);
                    nivel.tangente.splice(0,0,nivel.tangente[0],nivel.tangente[1],nivel.tangente[2],nivel.tangente[0],nivel.tangente[1],nivel.tangente[2]);
                    nivel.normal.splice(0,0,nivel.normal[0],nivel.normal[1],nivel.normal[2],nivel.normal[0],nivel.normal[1],nivel.normal[2]);
                    nivel.binormal.splice(0,0,nivel.binormal[0],nivel.binormal[1],nivel.binormal[2],nivel.binormal[0],nivel.binormal[1],nivel.binormal[2]);
                    nivel.cantidadPuntosFinal = nivel.cantidadPuntosFinal + 2;
                }

                if(tapaFinal)
                {
                    var puntos = 3*nivel.cantidadPuntosFinal;
                    nivel.posicion.push(nivel.posicion[puntos-3],nivel.posicion[puntos-2],nivel.posicion[puntos-1]);
                    nivel.posicion.push(nivel.posicion[puntos-3],nivel.posicion[puntos-2],nivel.posicion[puntos-1]);
                    nivel.tangente.push(nivel.tangente[puntos-3],nivel.tangente[puntos-2],nivel.tangente[puntos-1]);
                    nivel.tangente.push(nivel.tangente[puntos-3],nivel.tangente[puntos-2],nivel.tangente[puntos-1]);
                    nivel.normal.push(nivel.normal[puntos-3],nivel.normal[puntos-2],nivel.normal[puntos-1]);
                    nivel.normal.push(nivel.normal[puntos-3],nivel.normal[puntos-2],nivel.normal[puntos-1]);
                    nivel.binormal.push(nivel.binormal[puntos-3],nivel.binormal[puntos-2],nivel.binormal[puntos-1]);
                    nivel.binormal.push(nivel.binormal[puntos-3],nivel.binormal[puntos-2],nivel.binormal[puntos-1]);
                    nivel.cantidadPuntosFinal = nivel.cantidadPuntosFinal + 2;
                }                

                var buffersSuperficie = generarSuperficieDeBarrido(nivel, recorrido, escalados, angulosRotacion);
                var bufferUVAux = calcularValorBufferUVTapas(recorrido.posicion, recorrido.cantidadPuntosFinal);

                var posicion;
                var tapa = [];
                var normalTapa = [];
                var puntosTapa;

                var centroX;
                var centroY;
                var centroZ;

                
                if(tapaInicial)
                {
                    posicion = 6;
                    puntosTapa = recorrido.cantidadPuntosFinal;
                    centroX = 0;
                    centroY = 0;
                    centroZ = 0;
                    tapa = [];
                    for(var i=0; i< puntosTapa; i++)
                    {
                        tapa.push(buffersSuperficie.bufferPuntos[posicion],buffersSuperficie.bufferPuntos[posicion+1],buffersSuperficie.bufferPuntos[posicion+2]);
                        posicion += 3*nivel.cantidadPuntosFinal;
                    }
                    //console.log(tapa);
                    normalTapa = vec3.fromValues(recorrido.binormal[0],recorrido.binormal[1],recorrido.binormal[2]);
                    if(invertirNormalTapas)
                    {
                        vec3.scale(normalTapa,normalTapa,-1);
                    }
                    for(var i=0; i< puntosTapa; i++)
                    {
                        centroX += tapa[3*i];
                        centroY += tapa[3*i+1];
                        centroZ += tapa[3*i+2];

                    }
                    centroX = centroX/puntosTapa;
                    centroY = centroY/puntosTapa;
                    centroZ = centroZ/puntosTapa;     
                    posicion = 0;
                    for(var i=0; i< puntosTapa; i++)
                    {
                        buffersSuperficie.bufferPuntos[3*posicion] = centroX;
                        buffersSuperficie.bufferPuntos[3*posicion+1] = centroY;
                        buffersSuperficie.bufferPuntos[3*posicion+2] = centroZ;
                        buffersSuperficie.bufferPuntos[3*posicion+3] = tapa[3*i];
                        buffersSuperficie.bufferPuntos[3*posicion+4] = tapa[3*i+1];
                        buffersSuperficie.bufferPuntos[3*posicion+5] = tapa[3*i+2];

                        buffersSuperficie.bufferNormales[3*posicion] = normalTapa[0];
                        buffersSuperficie.bufferNormales[3*posicion+1] = normalTapa[1];
                        buffersSuperficie.bufferNormales[3*posicion+2] = normalTapa[2];
                        buffersSuperficie.bufferNormales[3*posicion+3] = normalTapa[0];
                        buffersSuperficie.bufferNormales[3*posicion+4] = normalTapa[1];
                        buffersSuperficie.bufferNormales[3*posicion+5] = normalTapa[2];

                        buffersSuperficie.bufferUV[2*posicion] = bufferUVAux.bufferUVCentro[2*i];
                        buffersSuperficie.bufferUV[2*posicion+1] = bufferUVAux.bufferUVCentro[2*i+1];
                        buffersSuperficie.bufferUV[2*posicion+2] = bufferUVAux.bufferUVBorde[2*i];
                        buffersSuperficie.bufferUV[2*posicion+3] = bufferUVAux.bufferUVBorde[2*i+1];
                        posicion += nivel.cantidadPuntosFinal;
                    }

                    
                }

                if(tapaFinal)
                {
                    posicion = 3*nivel.cantidadPuntosFinal-9;
                    puntosTapa = recorrido.cantidadPuntosFinal;
                    centroX = 0;
                    centroY = 0;
                    centroZ = 0;
                    tapa = [];
                    for(var i=0; i< puntosTapa; i++)
                    {
                        tapa.push(buffersSuperficie.bufferPuntos[posicion],buffersSuperficie.bufferPuntos[posicion+1],buffersSuperficie.bufferPuntos[posicion+2]);
                        posicion += 3*nivel.cantidadPuntosFinal;
                    }
                    normalTapa = vec3.fromValues(-1*recorrido.binormal[0],-1*recorrido.binormal[1],-1*recorrido.binormal[2]);
                    if(invertirNormalTapas)
                    {
                        vec3.scale(normalTapa,normalTapa,-1);
                    }
                    for(var i=0; i< puntosTapa; i++)
                    {
                        centroX += tapa[3*i];
                        centroY += tapa[3*i+1];
                        centroZ += tapa[3*i+2];
                    }
                    centroX = centroX/puntosTapa;
                    centroY = centroY/puntosTapa;
                    centroZ = centroZ/puntosTapa;     
                    posicion = nivel.cantidadPuntosFinal-2;
                    for(var i=0; i< puntosTapa; i++)
                    {
                        buffersSuperficie.bufferPuntos[3*posicion] = tapa[3*i];
                        buffersSuperficie.bufferPuntos[3*posicion+1] = tapa[3*i+1];
                        buffersSuperficie.bufferPuntos[3*posicion+2] = tapa[3*i+2];
                        buffersSuperficie.bufferPuntos[3*posicion+3] = centroX;
                        buffersSuperficie.bufferPuntos[3*posicion+4] = centroY;
                        buffersSuperficie.bufferPuntos[3*posicion+5] = centroZ;

                        buffersSuperficie.bufferNormales[3*posicion] = normalTapa[0];
                        buffersSuperficie.bufferNormales[3*posicion+1] = normalTapa[1];
                        buffersSuperficie.bufferNormales[3*posicion+2] = normalTapa[2];
                        buffersSuperficie.bufferNormales[3*posicion+3] = normalTapa[0];
                        buffersSuperficie.bufferNormales[3*posicion+4] = normalTapa[1];
                        buffersSuperficie.bufferNormales[3*posicion+5] = normalTapa[2];

                        buffersSuperficie.bufferUV[posicion] = bufferUVAux.bufferUVBorde[2*i];
                        buffersSuperficie.bufferUV[posicion+1] = bufferUVAux.bufferUVBorde[2*i+1];
                        buffersSuperficie.bufferUV[posicion+2] = bufferUVAux.bufferUVCentro[2*i];
                        buffersSuperficie.bufferUV[posicion+3] = bufferUVAux.bufferUVCentro[2*i+1];
                
                        posicion += nivel.cantidadPuntosFinal;
                    }
                }
                

                //console.log(nivel.cantidadPuntosFinal);
                var bufferIndice = obtenerIndexBuffer(recorrido.cantidadPuntosFinal,nivel.cantidadPuntosFinal);
                //console.log(bufferIndice);

                var supBarridoVerticeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, supBarridoVerticeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffersSuperficie.bufferPuntos), gl.STATIC_DRAW);    
            

                var supBarridoNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, supBarridoNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffersSuperficie.bufferNormales), gl.STATIC_DRAW);

                var supBarridoUVBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, supBarridoUVBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffersSuperficie.bufferUV), gl.STATIC_DRAW);
 
                var supBarridoIndexBuffer = gl.createBuffer();
                supBarridoIndexBuffer.number_vertex_point = bufferIndice.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, supBarridoIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(bufferIndice), gl.STATIC_DRAW); 

                return {
                    supBarridoVerticeBuffer,
                    supBarridoNormalBuffer,
                    supBarridoUVBuffer,
                    supBarridoIndexBuffer
                };
            }


            function generarRecta(longitud, cantidadPuntos = 2)
            {
                var paso = longitud/(cantidadPuntos-1);
                var inicial = -longitud/2;
                var posicion = [];
                var tangente = [];
                var normal = [];
                var binormal = [];
                var cantidadPuntosFinal = cantidadPuntos;
                for(var i=0; i<cantidadPuntos; i++)
                {
                    posicion.push((inicial+i*paso),0.0,0.0);
                    tangente.push(1.0,0.0,0.0);
                    normal.push(0.0,1.0,0.0);
                    binormal.push(0.0,0.0,-1.0);
                }

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };
            }

            function generarRecta2D(x1,y1,x2,y2,cantPuntos = 2)
            {
                var tangenteAux = vec3.fromValues(x2-x1,y2-y1,0);
                vec3.normalize(tangenteAux,tangenteAux);
                var binormalAux = vec3.fromValues(0,0,-1);
                var normalAux = vec3.create();
                vec3.cross(normalAux,tangenteAux,binormalAux);

                var pasoX = x2-x1/(cantPuntos-1);
                var pasoY = y2-y1/(cantPuntos-1);


                var posicion = [];
                var tangente = [];
                var normal = [];
                var binormal = [];
                var cantidadPuntosFinal = cantPuntos;
                for(var i=0; i<cantPuntos; i++)
                {
                    posicion.push((x1+i*pasoX),(y1+i*pasoY),0.0);
                    tangente.push(tangenteAux[0],tangenteAux[1],tangenteAux[2]);
                    normal.push(normalAux[0],normalAux[1],normalAux[2]);
                    binormal.push(binormalAux[0],binormalAux[1],binormalAux[2]);
                }

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };
            }

            function generarRectangulo(base, altura)
            {
                var posicion = 
                [
                    base/2,altura/2,0.0,
                    -base/2,altura/2,0.0,
                    -base/2,altura/2,0.0,
                    -base/2,-altura/2,0.0,
                    -base/2,-altura/2,0.0,
                    base/2,-altura/2,0.0,
                    base/2,-altura/2,0.0,
                    base/2,altura/2,0.0
                ];
                var tangente = 
                [
                    -1.0,0.0,0.0,
                    -1.0,0.0,0.0,
                    0.0,-1.0,0.0,
                    0.0,-1.0,0.0,
                    1.0,0.0,0.0,
                    1.0,0.0,0.0,
                    0.0,1.0,0.0,
                    0.0,1.0,0.0
                ];
                var normal = 
                [
                    0.0,-1.0,0.0,
                    0.0,-1.0,0.0,
                    1.0,0.0,0.0,
                    1.0,0.0,0.0,
                    0.0,1.0,0.0,
                    0.0,1.0,0.0,
                    -1.0,0.0,0.0,
                    -1.0,0.0,0.0
                ];
                var binormal = 
                [
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0,
                    0.0,0.0,-1.0
                ];
                var cantidadPuntosFinal = 8;
                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };
            }

            function generarArcoCircunferencia(radio,cantidadPuntos,anguloEnGrados=360,anguloInicialEnGrados=0)
            {
                var anguloInicial = anguloInicialEnGrados*Math.PI/180
                var anguloMax = (anguloEnGrados+anguloInicialEnGrados)*Math.PI/180;
                var pasoAngulo = (anguloMax-anguloInicial)/(cantidadPuntos-1);
                var posicion = [];
                var tangente = [];
                var normal = [];
                var binormal = [];
                var cantidadPuntosFinal = cantidadPuntos;
                var coseno;
                var seno;
                var angulo = anguloInicial;
                for(var i=0; i<cantidadPuntos;i++)
                {   
                    coseno = Math.cos(angulo);
                    seno = Math.sin(angulo);
                    posicion.push(radio*coseno,radio*seno,0.0);
                    tangente.push(-seno,coseno,0.0);
                    normal.push(-coseno,-seno,0.0);
                    binormal.push(0.0,0.0,-1.0);
                    angulo += pasoAngulo;
                }
                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };
            }
        
            function generarCirculoBezier(radio,cantidadPuntos)
            {
                const distancia = radio*4*(Math.sqrt(2)-1)/3;
                const puntosControl = 
                [
                    radio,0.0,0.0,
                    radio,distancia,0.0,
                    distancia,radio,0.0,
                    0.0,radio,0.0,

                    0.0,radio,0.0,
                    -distancia,radio,0.0,
                    -radio,distancia,0.0,
                    -radio,0.0,0.0,

                    -radio,0.0,0.0,
                    -radio,-distancia,0.0,
                    -distancia,-radio,0.0,
                    0.0,-radio,0.0,

                    0.0,-radio,0.0,
                    distancia,-radio,0.0,
                    radio,-distancia,0.0,
                    radio,0.0,0.0                  
                ];

                var buffers = bezierCompleto(puntosControl,cantidadPuntos, 3);

                var posicion = buffers.posicion;
                var tangente = buffers.tangente;
                var normal = buffers.normal;
                var binormal = buffers.binormal;
                var cantidadPuntosFinal = buffers.cantidadPuntosFinal;

                return{
                    posicion,
                    tangente,
                    normal,
                    binormal,
                    cantidadPuntosFinal
                };
            }
            
            function generarPrisma(ancho,alto,profundo,cantPuntos=16)
            {
                var nivel = generarRectangulo(ancho,alto);
                var cantPuntosRecta = Math.ceil(cantPuntos/nivel.cantidadPuntosFinal);
                var recorrido = generarRecta(profundo, cantPuntosRecta);
                var buffers = superficieBarridoCompleta(nivel,recorrido);
                var supBarridoVerticeBuffer = buffers.supBarridoVerticeBuffer;
                var supBarridoNormalBuffer = buffers.supBarridoNormalBuffer;
                var supBarridoUVBuffer = buffers.supBarridoUVBuffer;
                var supBarridoIndexBuffer = buffers.supBarridoIndexBuffer;

                return {
                    supBarridoVerticeBuffer,
                    supBarridoNormalBuffer,
                    supBarridoUVBuffer,
                    supBarridoIndexBuffer
                };
            }

            function generarCilindro(radio,profundo,cantpuntosCirculo=20,cantPuntosRecta=2)
            {   
                var nivel = generarArcoCircunferencia(radio,cantpuntosCirculo);
                var recorrido = generarRecta(profundo, cantPuntosRecta);
                var buffers = superficieBarridoCompleta(nivel,recorrido);
                var supBarridoVerticeBuffer = buffers.supBarridoVerticeBuffer;
                var supBarridoNormalBuffer = buffers.supBarridoNormalBuffer;
                var supBarridoUVBuffer = buffers.supBarridoUVBuffer;
                var supBarridoIndexBuffer = buffers.supBarridoIndexBuffer;

                return {
                    supBarridoVerticeBuffer,
                    supBarridoNormalBuffer,
                    supBarridoUVBuffer,
                    supBarridoIndexBuffer
                };
            }

            // para generar el anillo

            function generarColumaSoporte(bufferBarraLatera,bufferBarraCruzada, longitud, ancho,longitudBarraCruzada,color)
            {
                var columaSoporte = new Objeto3D();
                var objetoAuxiliar = new Objeto3D();
                objetoAuxiliar.setGeometria(bufferBarraLatera);
                objetoAuxiliar.setPosicion(longitud/2,ancho/2,0);
                objetoAuxiliar.setColor(color[0],color[1],color[2]);
                columaSoporte.agregarHijo(objetoAuxiliar);
                objetoAuxiliar = new Objeto3D();
                objetoAuxiliar.setGeometria(bufferBarraLatera);
                objetoAuxiliar.setPosicion(longitud/2,-ancho/2,0);
                objetoAuxiliar.setColor(color[0],color[1],color[2]);
                columaSoporte.agregarHijo(objetoAuxiliar);
                var rotacionBarraCruzada = Math.asin(ancho/longitudBarraCruzada);
                var alturaBarraCruzada = Math.cos(rotacionBarraCruzada)*longitudBarraCruzada;
                var cantidadBarrasCruzadas = Math.floor(longitud/alturaBarraCruzada);
                var posicion = (longitud-cantidadBarrasCruzadas*alturaBarraCruzada)/2+alturaBarraCruzada/2;
                for(var i = 0; i < cantidadBarrasCruzadas; i++)
                {
                    objetoAuxiliar = new Objeto3D();
                    objetoAuxiliar.setGeometria(bufferBarraCruzada);
                    objetoAuxiliar.setPosicion(posicion,0,0);
                    objetoAuxiliar.setRotacion(0,0,1,rotacionBarraCruzada);
                    objetoAuxiliar.setColor(color[0],color[1],color[2]);
                    columaSoporte.agregarHijo(objetoAuxiliar);
                    rotacionBarraCruzada *= -1;
                    posicion += alturaBarraCruzada;
                }
                return columaSoporte;

            }

            function generarModulos(ancho, alto, radioCurvatura, anguloArco, cantPuntosArco = 100, cantPuntosNivel = 24)
            {
                const min = Math.min(ancho,alto);
                const factorBorde = 0.2
                const distanciaEsquina = factorBorde*min;
                const gradoBezier = 2;
                const alto2 = alto/2-distanciaEsquina;
                const ancho2 = ancho/2-distanciaEsquina;
                const puntosControlNivel = [
                    ancho/2,-alto2,0.0,
                    ancho/2,0.0,0.0,
                    ancho/2,alto2,0.0,

                    ancho/2,alto2,0.0,
                    ancho2+distanciaEsquina/2,alto2+distanciaEsquina/2,0.0,
                    ancho2,alto/2,0.0,

                    ancho2,alto/2,0.0,
                    0.0,alto/2,0.0,
                    -ancho2,alto/2,0.0,

                    -ancho2,alto/2,0.0,
                    -ancho2-distanciaEsquina/2,alto2+distanciaEsquina/2,0.0,
                    -ancho/2,alto2,0.0,

                    -ancho/2,alto2,0.0,
                    -ancho/2,0.0,0.0,
                    -ancho/2,-alto2,0.0,

                    -ancho/2,-alto2,0.0,
                    -ancho2-distanciaEsquina/2,-alto2-distanciaEsquina/2,0.0,
                    -ancho2,-alto/2,0.0,

                    -ancho2,-alto/2,0.0,
                    0.0,-alto/2,0.0,
                    ancho2,-alto/2,0.0,

                    ancho2,-alto/2,0.0,
                    ancho2+distanciaEsquina/2,-alto2-distanciaEsquina/2,0.0,
                    ancho/2,-alto2,0.0
                ];

                var nivel = bezierCompleto2D(puntosControlNivel,cantPuntosNivel, gradoBezier);
                var recorrido = generarArcoCircunferencia(radioCurvatura,cantPuntosArco,anguloArco,-anguloArco/2);

                var supreficie = superficieBarridoCompleta(nivel,recorrido);
                return supreficie;
            }

            function generarCentroAnillo(radio, ancho, color)
            {
                const anchoborde = 0.3*ancho;
                const difRadio = anchoborde;
                
                const cantPuntosRecorrido = 6;
                const cantPuntosCirculo = 100;
                var objeto = new Objeto3D();

                const radioMin = radio-difRadio;
                const radioMedio = radio-difRadio/2;

                var objetoAux = new Objeto3D();
                var buffersAux = generarCilindro(radio,ancho,cantPuntosCirculo,cantPuntosRecorrido);
                objetoAux.setGeometria(buffersAux);
                objetoAux.setRotacion(0,1,0,Math.PI/2);
                objetoAux.setColor(color[0],color[1],color[2]);
                objeto.agregarHijo(objetoAux);
                
                const posTapas = (anchoborde + ancho)/2;

                var recorrido = generarCirculoBezier(radioMedio,cantPuntosCirculo);
                var nivel = generarRecta2D(difRadio/2,anchoborde/2,-difRadio/2,-anchoborde/2);
            
                buffersAux = superficieRevolucionCompleta(nivel,recorrido);
                objetoAux = new Objeto3D();
                objetoAux.setGeometria(buffersAux);
                objetoAux.setPosicion(0,0,-posTapas);
                objetoAux.setColor(color[0],color[1],color[2]);
                objeto.agregarHijo(objetoAux);

                buffersAux = superficieRevolucionCompleta(nivel,recorrido);
                objetoAux = new Objeto3D();
                objetoAux.setGeometria(buffersAux);
                objetoAux.setPosicion(0,0,posTapas);
                objetoAux.setRotacion(0,1,0,Math.PI);
                objetoAux.setColor(color[0],color[1],color[2]);
                objeto.agregarHijo(objetoAux);

                
                return objeto;
            }

            function generarAnillo()
            {
                // centro del anillo
                const factorTamanio = 0.5;

                const radioInterno = factorTamanio*1.5;
                const anchoCentro = factorTamanio*0.3;
                const colorCentro = vec3.fromValues(0.5,0.8,0.0);

                // vigas
                const anchoLateral = factorTamanio*0.1;
                const radioviga = factorTamanio*0.04;
                const anchoViga = factorTamanio*0.3;
                const colorVigas = vec3.fromValues(0.8,0.6,0.7);
                const cantPuntosCruzado = 20;
                const largoCrucado = factorTamanio*0.5;

                // anillo externo 
                const radio = factorTamanio*7.5;
                const radioAnillo = factorTamanio*0.5;
                const colorAnillo = vec3.fromValues(0.8,0.8,0.8);
                const cantPuntosAnilloN = 100;
                const cantPuntosAnilloR = 200;

                // modulo 
                const anchoModulo = factorTamanio*1.1;
                const altoModulo = factorTamanio*3.0;
                const colorModulo = vec3.fromValues(0.0,0.75,0.75);
                
                const cantidadModulos = variablesGUI.cantidadModulos;

                var objeto = new Objeto3D();

                var hijo = generarCentroAnillo(radioInterno,anchoCentro,colorCentro);
                //hijo.setRotacion(1,0,0,Math.PI/2);
                objeto.agregarHijo(hijo);

                var nivel = generarArcoCircunferencia(radioAnillo,cantPuntosAnilloN)
                var recorrido = generarArcoCircunferencia(radio,cantPuntosAnilloR)
                var supreficie = superficieBarridoCompleta(nivel,recorrido);
                hijo = new Objeto3D();
                hijo.setGeometria(supreficie);
                hijo.setColor(colorAnillo[0],colorAnillo[1],colorAnillo[2]);
                objeto.agregarHijo(hijo);

                supreficie = generarPrisma(anchoLateral,anchoLateral,radio);
                var supreficie2 = generarCilindro(radioviga,largoCrucado,cantPuntosCruzado);
                
                var supreficie3 = generarModulos(anchoModulo, altoModulo, radio, 360/(2*cantidadModulos));

                var anguloInicial = 0;
                var anguloPaso = Math.PI*2/cantidadModulos;

                for(var i = 0; i < cantidadModulos; i++)
                {
                    hijo = generarColumaSoporte(supreficie,supreficie2,radio,anchoViga,largoCrucado,colorVigas);
                    hijo.setRotacion(0,0,1,anguloInicial);
                    objeto.agregarHijo(hijo);
                    hijo = new Objeto3D();
                    hijo.setGeometria(supreficie3);
                    hijo.setColor(colorModulo[0],colorModulo[1],colorModulo[2]);
                    hijo.setRotacion(0,0,1,anguloInicial);
                    objeto.agregarHijo(hijo);
                    anguloInicial += anguloPaso;
                }

                return objeto
            }

            // para generar los paneles solares

            function generarParPanelSolar(buffercilindro,bufferpanel, largoPanel, largoCilindro, color)
            {
                var objeto = new Objeto3D();
                var hijo = new Objeto3D();
                hijo.setGeometria(buffercilindro);
                hijo.setColor(color[0],color[1],color[2]);
                objeto.agregarHijo(hijo);

                hijo = new Objeto3D();
                hijo.setGeometria(bufferpanel);
                hijo.setColor(color[0],color[1],color[2]);
                hijo.setPosicion(-(largoPanel+largoCilindro)/2,0.0,0.0);
                objeto.agregarHijo(hijo);

                hijo = new Objeto3D();
                hijo.setGeometria(bufferpanel);
                hijo.setColor(color[0],color[1],color[2]);
                hijo.setPosicion((largoPanel+largoCilindro)/2,0.0,0.0);
                objeto.agregarHijo(hijo);

                return objeto;
            }

            function generarPanelesSolares()
            {
                const factorEscala = 1.2;

                punteroPaneles = [];

                var cantidadFilasPaneles = variablesGUI.cantidadFilasPaneles;

                // panel 
                const anchoPanel = factorEscala*0.6;
                const altoPanel = factorEscala*0.1;
                const profundidadPanel = factorEscala*2;

                const radioBarra = factorEscala*0.04;
                const largoBarra = factorEscala*0.5;

                const colorPaneles = vec3.fromValues(0.8,0.8,0.2);

                // barra
                const largoOriginal = factorEscala*1.2;
                const largoPanel = factorEscala*0.7;
                const radioCentral = factorEscala*0.08;

                const colorBarra = vec3.fromValues(0.8,0.6,0.7);

                const centroPaneles = largoOriginal+largoPanel*cantidadFilasPaneles/2;

                var objeto = new Objeto3D();
                var hijo = new Objeto3D();
                var superficie1 = generarCilindro(radioCentral,largoOriginal+largoPanel*cantidadFilasPaneles); 
                hijo.setGeometria(superficie1);
                hijo.setColor(colorBarra[0],colorBarra[1],colorBarra[2]);
                hijo.setRotacion(0,0,1,Math.PI/2);
                hijo.setPosicion(0.0,-(largoOriginal+largoPanel*cantidadFilasPaneles)/2,0.0);
                objeto.agregarHijo(hijo);

                var posInicial = largoOriginal+largoPanel/2;

                superficie1 = generarPrisma(anchoPanel,altoPanel,profundidadPanel);
                var superficie2 = generarCilindro(radioBarra,largoBarra);
                for(var i = 0; i<cantidadFilasPaneles;i++)
                {
                    var hijo = generarParPanelSolar(superficie2,superficie1, profundidadPanel, largoBarra, colorPaneles);
                    hijo.setPosicion(0.0,-posInicial,0.0);
                    objeto.agregarHijo(hijo);
                    punteroPaneles.push(hijo);

                    posInicial += largoPanel

                }
                hijo = new Objeto3D();
                hijo.setPosicion(0.0,-(largoOriginal+cantidadFilasPaneles*largoPanel/2),0.0);
                objeto.agregarHijo(hijo);
                hijo.agregarHijo(camara2);
                camara2.setRadio(8.0);


                return objeto;

            }

            // para generar el nucleo

            function generarNucleo()
            {
                const factorEscala = 0.7;
                // modulo bezier
                const anchoMB = factorEscala*0.5;
                const altoMB =  factorEscala*0.5;
                const profundidadMB =  factorEscala*0.5;
                const colorMB = vec3.fromValues(0.8,0.0,0.8);
                const minladoMB = Math.min(anchoMB,altoMB);
                const radioEsquina = 0.2*minladoMB;
                const gradoBezierMB = 2;
                const puntosControlMB = 
                [
                    anchoMB/2,-altoMB/2+radioEsquina,0.0,
                    anchoMB/2,0.0,0.0,
                    anchoMB/2,altoMB/2-radioEsquina,0.0,

                    anchoMB/2,altoMB/2-radioEsquina,0.0,
                    anchoMB/2,altoMB/2,0.0,
                    anchoMB/2-radioEsquina,altoMB/2,0.0,

                    anchoMB/2-radioEsquina,altoMB/2,0.0,
                    0.0,altoMB/2,0.0,
                    -anchoMB/2+radioEsquina,altoMB/2,0.0,

                    -anchoMB/2+radioEsquina,altoMB/2,0.0,
                    -anchoMB/2,altoMB/2,0.0,
                    -anchoMB/2,altoMB/2-radioEsquina,0.0,

                    -anchoMB/2,altoMB/2-radioEsquina,0.0,
                    -anchoMB/2,0.0,0.0,
                    -anchoMB/2,-altoMB/2+radioEsquina,0.0,

                    -anchoMB/2,-altoMB/2+radioEsquina,0.0,
                    -anchoMB/2,-altoMB/2,0.0,
                    -anchoMB/2+radioEsquina,-altoMB/2,0.0,

                    -anchoMB/2+radioEsquina,-altoMB/2,0.0,
                    0.0,-altoMB/2,0.0,
                    anchoMB/2-radioEsquina,-altoMB/2,0.0,

                    anchoMB/2-radioEsquina,-altoMB/2,0.0,
                    anchoMB/2,-altoMB/2,0.0,
                    anchoMB/2,-altoMB/2+radioEsquina,0.0
                ];

                // modulo cuasi esferico
                const radioMCE = factorEscala*0.7;
                const angulo = 120;
                const invertirNormal = true;
                const colorMCE = vec3.fromValues(0.8,0.6,0.0);
                const largoMCE = 2*radioMCE*Math.sin(angulo*Math.PI/360);


                // modulo cuasi cilíndrico
                const radioMCC = factorEscala*0.7;
                const largoMCC = factorEscala*2.5;
                const colorMCC = vec3.fromValues(0.8,0.6,0.0);
                const minladoMCC = Math.min(largoMCC,2*radioMCC);
                const recorteEsquina = 0.2*minladoMCC;
                const gradoBezierMCC = 1;
                const puntosControlMCC = 
                [
                    0.0,-largoMCC/2, 0.0,
                    radioMCC-recorteEsquina,-largoMCC/2,0.0,

                    radioMCC-recorteEsquina,-largoMCC/2,0.0,
                    radioMCC,-largoMCC/2+recorteEsquina,0.0,

                    radioMCC,-largoMCC/2+recorteEsquina,0.0,
                    radioMCC,largoMCC/2-recorteEsquina,0.0,

                    radioMCC,largoMCC/2-recorteEsquina,0.0,
                    radioMCC-recorteEsquina,largoMCC/2,0.0,

                    radioMCC-recorteEsquina,largoMCC/2,0.0,
                    0.0,largoMCC/2,0.0
                ];

                var objeto = new Objeto3D();
                var hijo = new Objeto3D();
                
                var nivel = bezierCompleto2D(puntosControlMB,160, gradoBezierMB);
                var recorrido = generarRecta(profundidadMB);
                var superficie = superficieBarridoCompleta(nivel,recorrido);

                hijo.setGeometria(superficie);
                hijo.setColor(colorMB[0],colorMB[1],colorMB[2]);
                hijo.setRotacion(0,1,0,Math.PI/2);
                hijo.setPosicion(0.0,0.0,(largoMCC+profundidadMB)/2);
                objeto.agregarHijo(hijo);

                hijo = new Objeto3D();
                hijo.setGeometria(superficie);
                hijo.setColor(colorMB[0],colorMB[1],colorMB[2]);
                hijo.setRotacion(0,1,0,Math.PI/2);
                hijo.setPosicion(0.0,0.0,-(largoMCC+profundidadMB)/2);
                objeto.agregarHijo(hijo);
                
                nivel = bezierCompleto2D(puntosControlMCC,10, gradoBezierMCC);
                recorrido = generarArcoCircunferencia(0,100);
                superficie = superficieRevolucionCompleta(nivel,recorrido,false,false,false);

                hijo = new Objeto3D();
                hijo.setGeometria(superficie);
                hijo.setColor(colorMCE[0],colorMCE[1],colorMCE[2]);
                objeto.agregarHijo(hijo);
                
                hijo = new Objeto3D();
                hijo.setGeometria(superficie);
                hijo.setColor(colorMCE[0],colorMCE[1],colorMCE[2]);
                hijo.setPosicion(0.0,0.0,-(largoMCC+profundidadMB));
                objeto.agregarHijo(hijo);

                nivel = generarArcoCircunferencia(radioMCE,50,angulo,-angulo/2);
                recorrido = generarArcoCircunferencia(0,100);
                superficie = superficieRevolucionCompleta(nivel,recorrido,invertirNormal);

                hijo = new Objeto3D();
                hijo.setGeometria(superficie);
                hijo.setColor(colorMCE[0],colorMCE[1],colorMCE[2]);
                hijo.setPosicion(0.0,0.0,(largoMCC+largoMCE)/2+profundidadMB);
                objeto.agregarHijo(hijo);
                

                return objeto;
            }

            // estación espacial

            function generarEstacionEspacial()
            {
                const distaciaPanelesSolares = 3;

                var objeto = new Objeto3D();
                var hijo = generarNucleo();
                objeto.agregarHijo(hijo);

                punteroAnillo = generarAnillo();
                objeto.agregarHijo(punteroAnillo);

                hijo = new Objeto3D();
                hijo.setRotacion(1,0,0,Math.PI/2);
                hijo.setPosicion(0.0,0.0,-distaciaPanelesSolares);

                var hijo2 = generarPanelesSolares();
                hijo.agregarHijo(hijo2);
                objeto.agregarHijo(hijo);

                punteroPadrePanelesSolares = hijo
                punteroModuloPanelesSolares = hijo2;
                //hijo.setPosicion(0.0,0.0,(largoMCC+largoMCE)/2+profundidadMB);
                objeto.agregarHijo(camara1);
                camara1.setRadio(8.0);

                return objeto;
            }

            // tierra

            function generarTierra()
            {
                const radio = 500;
                const color = vec3.fromValues(0.0,0.8,1.0);

                var objeto = new Objeto3D()
                var nivel = generarArcoCircunferencia(radio,100,90,-90);
                var recorrido = generarArcoCircunferencia(0,100);
                var superficie = superficieRevolucionCompleta(nivel,recorrido,false,false,false);
                objeto.setGeometria(superficie);
                objeto.setColor(color[0],color[1],color[2]);

                return objeto;

            }

            // capsula
            
            function generarCapsula()
            {

                // central
                
                const colorCentral = vec3.fromValues(0.8,0.6,0.0);
                const radioC1 = 0.1;
                const radioC2 = 0.14;
                const radioC3 = 0.16;
                const radioC4 = 0.3;
                const radioC5 = 0.25;
                const radioC6 = 0.1;
                const largoC1 = 0.08;
                const largoC2 = 0.4;
                const largoC3 = 0.04;
                const largoC4 = 0.01;
                const gradoBezierC = 2;

                const puntosControlC =
                [
                    radioC1,0.0,0.0,
                    (radioC1+radioC2)/2,largoC1/2,0.0,
                    radioC2,largoC1,0.0,

                    radioC2,largoC1,0.0,
                    (radioC3+radioC2)/2,largoC1,0.0,
                    radioC3,largoC1,0.0,

                    radioC3,largoC1,0.0,
                    radioC4,largoC1+largoC2/2,0.0,
                    radioC4,largoC1+largoC2,0.0,

                    radioC4,largoC1+largoC2,0.0,
                    (radioC4+radioC5)/2,largoC1+largoC2+largoC3/2,0.0,
                    radioC5,largoC1+largoC2+largoC3,0.0,

                    radioC5,largoC1+largoC2+largoC3,0.0,
                    (radioC5+radioC6)/2,largoC1+largoC2+largoC3+largoC4/2,0.0,
                    radioC6,largoC1+largoC2+largoC3+largoC4,0.0
                ];

                // cohete
                const radioCohete = 0.1;
                const radioCoheteMin = 0.02;
                const longitudCohete = 0.2;
                const colorCohete = vec3.fromValues(0.3,0.3,0.3);
                const gradoBezierCohete = 2;
                const deltaX = 0.001;
                const puntosControlCohete =
                [
                    -radioCoheteMin-deltaX,0.0,0.0,
                    -radioCohete-deltaX,-longitudCohete/2,0.0,
                    -radioCohete-deltaX,-longitudCohete,0.0,

                    -radioCohete+deltaX,-longitudCohete,0.0,
                    -radioCohete+deltaX,-longitudCohete/2,0.0,
                    -radioCoheteMin+deltaX,0.0,0.0,
                ];



                var objeto = new Objeto3D();
                var hijo = new Objeto3D();
                
                var nivel = bezierCompleto2D(puntosControlC,100, gradoBezierC);
                var recorrido = generarCirculoBezier(0.0001,100);
                var superficie = superficieRevolucionCompleta(nivel,recorrido,true);
                hijo.setGeometria(superficie);
                hijo.setColor(colorCentral[0],colorCentral[1],colorCentral[2]);
                hijo.setPosicion(0.0,0.0,+(largoC1+largoC2+largoC3+largoC4)/2);
                objeto.agregarHijo(hijo);

                nivel = bezierCompleto2D(puntosControlCohete,20, gradoBezierCohete);
                superficie = superficieRevolucionCompleta(nivel,recorrido,true,true,false);
                hijo = new Objeto3D();
                hijo.setGeometria(superficie);
                hijo.setColor(colorCohete[0],colorCohete[1],colorCohete[2]);
                hijo.setRotacion(0,1,0,Math.PI);
                hijo.setPosicion(0.0,0.0,-(largoC1+largoC2+largoC3+largoC4)/2);
                objeto.agregarHijo(hijo);

                return objeto;
            }

            var sBVerticeBuffer;
            var sBNormalBuffer;
            var sBIndexBuffer;

            function probarSuperficieDeBarrido()
            {
                
                const nivelControl = 
                [
                    0.5,0.0,0.0,
                    0.5,0.5,0.0,
                    0.0,0.5,0.0,

                    0.0,0.5,0.0,
                    -0.5,0.5,0.0,
                    -0.5,0.0,0.0,

                    -0.5,0.0,0.0,
                    -0.5,-0.5,0.0,
                    0.0,-0.5,0.0,

                    0.0,-0.5,0.0,
                    0.5,-0.5,0.0,
                    0.5,0.0,0.0,
                ];
                
                const recorridoControl = 
                [
                    -1.0,0.0,0.0,
                    -1.0,0.0,-1.0,
                    0.0,0.0,-1.0,

                    0.0,0.0,-1.0,
                    1.0,0.0,-1.0,
                    1.0,0.0,0.0,
                ];
                
                /*
                const recorridoControl = 
                [
                    -1.0,0.0,0.0,
                    -1.0,-1.0,0.0,
                    0.0,-1.0,0.0,

                    0.0,-1.0,0.0,
                    1.0,-1.0,0.0,
                    1.0,0.0,0.0,
                ];
                */
                
                //var recorrido = bezierCompleto(recorridoControl,100,2);
                // var nivel = bezierCompleto(nivelControl,100,2);
                var recorrido = generarRecta(2)
                var nivel = generarArcoCircunferencia(1,100);
                var buffers = generarSuperficieDeBarrido(nivel,recorrido);

                //console.log(buffers.bufferPuntos);
                //console.log(buffers.bufferNormales);
                //console.log(buffers.bufferIndices);

                sBVerticeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sBVerticeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffers.bufferPuntos), gl.STATIC_DRAW);    
            

                sBNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sBNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffers.bufferNormales), gl.STATIC_DRAW);
                
                
                sBIndexBuffer = gl.createBuffer();
                sBIndexBuffer.number_vertex_point = buffers.bufferIndices.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sBIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(buffers.bufferIndices), gl.STATIC_DRAW);  
                
                //var recorrido = bezierCompleto(recorridoControl,100,2);
                //var nivel = bezierCompleto(nivelControl,100,2);
                buffersSupBarrido = superficieBarridoCompleta(nivel,recorrido);

            }

            function inicializarObjetos()
            {

                objetos3D = new Objeto3D();

                var hijo = generarTierra();

                hijo.setPosicion(0,-300,-500);
                hijo.setRotacion(1,0,0,-Math.PI/4)
                objetos3D.agregarHijo(hijo);

                var hijo2 = generarEstacionEspacial();
                hijo2.setEscala(0.3,0.3,0.3);
                hijo2.setRotacion(0,-1,-1,0.5*Math.PI);
                objetos3D.agregarHijo(hijo2); 

                punteroEstacionEspacial = hijo2;

                hijo2 = new Movil();
                capsula = hijo2;
                hijo2.setPosicion(0.0,0.0,2.0);

                
                var hijo3 = generarCapsula();
                hijo3.setEscala(0.5,0.5,0.5);
                //hijo3.setRotacion(0,1,0,0.75*Math.PI);

                hijo3.agregarHijo(camara3);
                camara3.setRadio(1.4);
                camara3.setPhi(Math.PI);
                //camara3.setTheta(0.35*Math.PI);

                hijo2.agregarHijo(hijo3);
                objetos3D.agregarHijo(hijo2);

                var controller = gui.add(variablesGUI,"cantidadModulos",2,8,1);
                controller.name("Cantidad de Módulos");
                controller = gui.add(variablesGUI,"cantidadFilasPaneles",1,10,1);
                controller.name("Filas de Paneles Solares");
                controller = gui.add(variablesGUI,"angulosPaneles",0,360);
                controller.name("Ángulo de los Paneles Solares");
                controller = gui.add(variablesGUI,"velocidadAnillo",-10,10);
                controller.name("Velocidad de Rotación Anillo");
            }

            /*
            *
            *
            * 
            * 
            * 
            */
            function setupVertexShaderMatrix(){
                var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");
                var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                gl.uniformMatrix4fv(modelMatrixUniform, false, modelMatrix);
                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
                gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            } 
            
            function setupVertexShaderMatrix2(){
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");

                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
            }       
            
            function drawScene()
            {
                setupVertexShaderMatrix();

                /*
                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, trianglesNormalBuffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trianglesIndexBuffer);
                gl.drawElements( gl.TRIANGLE_STRIP, trianglesIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                */

                /*
                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, sBVerticeBuffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, sBNormalBuffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sBIndexBuffer);
                gl.drawElements( gl.TRIANGLE_STRIP, sBIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                */
                
                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffersSupBarrido.supBarridoVerticeBuffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffersSupBarrido.supBarridoNormalBuffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffersSupBarrido.supBarridoIndexBuffer);
                gl.drawElements( gl.TRIANGLE_STRIP, buffersSupBarrido.supBarridoIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
                
                //gl.drawElements( gl.LINE_STRIP, sBIndexBuffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);

            }

            function animate(){
                
                rotate_angle += 0.01;
                mat4.identity(modelMatrix);
                //mat4.rotate(modelMatrix,modelMatrix, rotate_angle, [1.0, 0.0, 1.0]);
                //mat4.identity(viewMatrix);
                //mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
                //mat4.rotate(viewMatrix,viewMatrix, rotate_angle, [-1.0, 0.0, 0.0]);


                mat4.identity(normalMatrix);
                mat4.multiply(normalMatrix,viewMatrix,modelMatrix);
                mat4.invert(normalMatrix,normalMatrix);
                mat4.transpose(normalMatrix,normalMatrix);

            }
            
            function tick(){

                requestAnimationFrame(tick);
                setupVertexShaderMatrix2();

                objetos3D.dibujar(viewMatrix);
                if(isMouseDown)
                    actualizarOrientacion();
                viewMatrix = camaraElegida.getMatrizVista();

                //rotate_angle += 0.01;
                //camaraElegida.setPhi(rotate_angle);

                if(cantidadFilasPanelesActual != variablesGUI.cantidadFilasPaneles)
                {
                    cantidadFilasPanelesActual = variablesGUI.cantidadFilasPaneles;
                    punteroPadrePanelesSolares.quitarHijo(punteroModuloPanelesSolares);
                    punteroModuloPanelesSolares = generarPanelesSolares();
                    punteroPadrePanelesSolares.agregarHijo(punteroModuloPanelesSolares);
                }

                var angulosPaneles = variablesGUI.angulosPaneles*Math.PI/180;
                for(var i = 0; i<variablesGUI.cantidadFilasPaneles; i++)
                {
                    punteroPaneles[i].setRotacion(1,0,0,angulosPaneles);
                }

                if(cantidadModulosActual != variablesGUI.cantidadModulos)
                {
                    cantidadModulosActual = variablesGUI.cantidadModulos;
                    punteroEstacionEspacial.quitarHijo(punteroAnillo);
                    punteroAnillo = generarAnillo();
                    punteroEstacionEspacial.agregarHijo(punteroAnillo);

                }
                
                punteroAnillo.setRotacion(0,0,1,anguloAnillo);
                anguloAnillo += variablesGUI.velocidadAnillo/100;
                
                //objetos3D.setRotacion(0,1,0,rotate_angle);

                //drawScene();
                //animate();
            }



            $("#contenedor3d").mousemove(function(e){ 
                mouse.x = e.clientX || e.pageX; 
                mouse.y = e.clientY || e.pageY 
            });
            
            $('#contenedor3d').mousedown(function(event){		
                isMouseDown = true;        
            });

            $('#contenedor3d').on('wheel', function(event){

                // deltaY obviously records vertical scroll, deltaX and deltaZ exist too
                if(event.originalEvent.deltaY < 0){
                // wheeled up
                    radioCamara = camaraElegida.getRadio();
                    radioCamara -= pasoRadio;
                    if(radioCamara< 0)
                        radioCamara = 0;
                    camaraElegida.setRadio(radioCamara);
                }
                else {
                // wheeled down
                    radioCamara = camaraElegida.getRadio();
                    radioCamara += pasoRadio;
                    camaraElegida.setRadio(radioCamara);
                }
            });

            $('body').mouseup(function(event){
                isMouseDown = false;		
            });

            $('body').on("keydown",function(event){
                //console.log(event);
                var radioCamara;
                switch(event.key){
                    case "1":
                        camaraElegida = camara1;
                        pasoRadio = pasoRadioC1;
                        pasoAngulo = pasoAnguloC1;
                    break;
                    case "2":
                        camaraElegida = camara2;
                        pasoRadio = pasoRadioC1;
                        pasoAngulo = pasoAnguloC1;
                    break;
                    case "3":
                        camaraElegida = camara3;
                        pasoRadio = pasoRadioC3;
                        pasoAngulo = pasoAnguloC3;
                    break;  
                    case "z":
                        radioCamara = camaraElegida.getRadio();
                        radioCamara -= pasoRadio;
                        if(radioCamara< 0)
                            radioCamara = 0;
                        camaraElegida.setRadio(radioCamara);
                    break;
                    case "x":
                        radioCamara = camaraElegida.getRadio();
                        radioCamara += pasoRadio;
                        camaraElegida.setRadio(radioCamara);
                    break;  


                    case "w":
                        capsula.moverHaciaAdelante(pasoDistaciaCapsula);
                    break; 
                    case "s":
                        capsula.moverHaciaAdelante(-pasoDistaciaCapsula);
                    break;    
                    case "a":
                        capsula.moverHaciaLaIzquierda(pasoDistaciaCapsula);
                    break; 
                    case "d":
                        capsula.moverHaciaLaIzquierda(-pasoDistaciaCapsula);
                    break;    
                    case "q":
                        capsula.moverHaciaArriba(pasoDistaciaCapsula);
                    break; 
                    case "e":
                        capsula.moverHaciaArriba(-pasoDistaciaCapsula);
                    break;         
                    

                    case "j":
                        capsula.girarAnguloGuiniada(pasoAnguloCapsula);
                    break; 
                    case "l":
                        capsula.girarAnguloGuiniada(-pasoAnguloCapsula);
                    break;  
                    case "i":
                        capsula.girarAnguloCabeceo(pasoAnguloCapsula);
                    break; 
                    case "k":
                        capsula.girarAnguloCabeceo(-pasoAnguloCapsula);
                    break;  
                }
                    
            });    

            function actualizarOrientacion()
            {
                var deltaX=0;
                if (previousClientX) deltaX=-(mouse.x - previousClientX);

                var deltaY=0;
                if (previousClientX) deltaY= (mouse.y-previousClientY);

                previousClientX = mouse.x;
                previousClientY = mouse.y;

                var phi = camaraElegida.getPhi();
                var theta = camaraElegida.getTheta();
                phi += deltaX*pasoAngulo;
                theta += deltaY*pasoAngulo;

                camaraElegida.setPhi(phi);
                camaraElegida.setTheta(theta);
            }

            window.onload=initWebGL;

        </script>

        
    </body>
</html>
